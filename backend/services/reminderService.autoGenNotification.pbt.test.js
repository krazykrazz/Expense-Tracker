/**
 * Property-Based Tests for ReminderService Auto-Generated Cycle Notifications
 * Feature: billing-cycle-automation
 * 
 * Using fast-check library for property-based testing
 * 
 * **Validates: Requirements 2.1, 2.2, 2.4, 4.1**
 */

const fc = require('fast-check');
const { pbtOptions } = require('../test/pbtArbitraries');

const reminderService = require('./reminderService');
const billingCycleRepository = require('../repositories/billingCycleRepository');
const statementBalanceService = require('./statementBalanceService');

// Mock activity log service (imported transitively by reminderService)
jest.mock('./activityLogService');

describe('ReminderService Auto-Generated Cycle Notifications - Property Tests', () => {
  let originalFindUnreviewed;
  let originalGetCardsNeeding;
  let originalFindByPmAndCycleEnd;

  beforeEach(() => {
    originalFindUnreviewed = billingCycleRepository.findUnreviewedAutoGenerated;
    originalGetCardsNeeding = billingCycleRepository.getCreditCardsNeedingBillingCycleEntry;
    originalFindByPmAndCycleEnd = billingCycleRepository.findByPaymentMethodAndCycleEnd;
  });

  afterEach(() => {
    billingCycleRepository.findUnreviewedAutoGenerated = originalFindUnreviewed;
    billingCycleRepository.getCreditCardsNeedingBillingCycleEntry = originalGetCardsNeeding;
    billingCycleRepository.findByPaymentMethodAndCycleEnd = originalFindByPmAndCycleEnd;
  });

  // --- Arbitraries ---

  /**
   * Generate a billing cycle record with controlled is_user_entered and reviewed_at.
   * This lets fast-check explore the full space of reviewed vs unreviewed cycles.
   */
  const billingCycleRecordArb = (cardId, displayName, fullName) =>
    fc.record({
      id: fc.integer({ min: 1, max: 10000 }),
      payment_method_id: fc.constant(cardId),
      cycle_start_date: fc.constant('2026-01-16'),
      cycle_end_date: fc.constantFrom('2026-02-15', '2026-03-15', '2026-04-15'),
      is_user_entered: fc.constantFrom(0, 1),
      actual_statement_balance: fc.oneof(
        fc.constant(0),
        fc.float({ min: Math.fround(0.01), max: Math.fround(5000), noNaN: true })
          .map(n => Math.round(n * 100) / 100)
      ),
      calculated_statement_balance: fc.float({ min: Math.fround(0), max: Math.fround(5000), noNaN: true })
        .map(n => Math.round(n * 100) / 100),
      reviewed_at: fc.constantFrom(null, '2026-02-01T12:00:00Z'),
      display_name: fc.constant(displayName),
      full_name: fc.constant(fullName)
    });

  /**
   * Generate a set of billing cycle records for multiple cards with varying review states.
   */
  const cycleRecordSetArb = fc.integer({ min: 1, max: 5 }).chain(numCards => {
    const cards = Array.from({ length: numCards }, (_, i) => ({
      id: i + 1,
      displayName: `Card ${i + 1}`,
      fullName: `Test Credit Card ${i + 1}`
    }));

    // Generate 1-3 records per card
    const recordArbs = cards.map(card =>
      fc.array(
        billingCycleRecordArb(card.id, card.displayName, card.fullName),
        { minLength: 1, maxLength: 3 }
      )
    );

    return fc.tuple(...recordArbs).map(recordArrays => ({
      cards,
      allRecords: recordArrays.flat()
    }));
  });

  // --- Property 4 Tests ---

  /**
   * Feature: billing-cycle-automation, Property 4: Notification Correctness
   * **Validates: Requirements 2.1, 2.2, 2.4**
   * 
   * For any set of billing cycle records with varying is_user_entered and
   * reviewed_at values, notifications appear exactly for records
   * where is_user_entered = 0 AND reviewed_at IS NULL, and each
   * notification contains the credit card's display name and cycle end date.
   */
  test('Property 4: Notification Correctness — notifications match exactly unreviewed cycles', async () => {
    await fc.assert(
      fc.asyncProperty(
        cycleRecordSetArb,
        async ({ allRecords }) => {
          // Determine which records are "unreviewed auto-generated"
          const expectedUnreviewed = allRecords.filter(
            r => r.is_user_entered === 0 && r.reviewed_at === null
          );

          // Mock findUnreviewedAutoGenerated to return exactly the unreviewed ones
          // (this mirrors what the real DB query does with its WHERE clause)
          billingCycleRepository.findUnreviewedAutoGenerated = async () => expectedUnreviewed;

          const result = await reminderService.getAutoGeneratedCycleNotifications();

          // Count must match exactly
          expect(result.count).toBe(expectedUnreviewed.length);
          expect(result.cycles.length).toBe(expectedUnreviewed.length);

          // Each notification must contain displayName and cycleEndDate from the record
          for (let i = 0; i < expectedUnreviewed.length; i++) {
            const record = expectedUnreviewed[i];
            const notification = result.cycles[i];

            expect(notification.paymentMethodId).toBe(record.payment_method_id);
            expect(notification.displayName).toBe(record.display_name || record.full_name);
            expect(notification.cycleEndDate).toBe(record.cycle_end_date);
          }
        }
      ),
      pbtOptions()
    );
  });

  /**
   * Property 4 continued: Reviewed cycles (user entered or has actual balance) produce no notifications
   * **Validates: Requirements 2.4**
   */
  test('Property 4: Notification Correctness — reviewed cycles produce zero notifications', async () => {
    await fc.assert(
      fc.asyncProperty(
        // Generate records that are all "reviewed" (is_user_entered=1 OR actual_statement_balance>0)
        fc.array(
          fc.record({
            id: fc.integer({ min: 1, max: 10000 }),
            payment_method_id: fc.integer({ min: 1, max: 10 }),
            cycle_start_date: fc.constant('2026-01-16'),
            cycle_end_date: fc.constant('2026-02-15'),
            is_user_entered: fc.constant(1),
            actual_statement_balance: fc.float({ min: Math.fround(0.01), max: Math.fround(5000), noNaN: true })
              .map(n => Math.round(n * 100) / 100),
            calculated_statement_balance: fc.float({ min: Math.fround(0), max: Math.fround(5000), noNaN: true })
              .map(n => Math.round(n * 100) / 100),
            display_name: fc.constant('Reviewed Card'),
            full_name: fc.constant('Reviewed Credit Card')
          }),
          { minLength: 0, maxLength: 5 }
        ),
        async (reviewedRecords) => {
          // All records are reviewed, so the DB query returns nothing
          billingCycleRepository.findUnreviewedAutoGenerated = async () => [];

          const result = await reminderService.getAutoGeneratedCycleNotifications();

          expect(result.count).toBe(0);
          expect(result.cycles).toEqual([]);
        }
      ),
      pbtOptions()
    );
  });

  /**
   * Property 4 continued: Notification uses display_name, falling back to full_name
   * **Validates: Requirements 2.2**
   */
  test('Property 4: Notification Correctness — displayName falls back to full_name when display_name is null', async () => {
    await fc.assert(
      fc.asyncProperty(
        fc.boolean(), // whether display_name is present
        fc.string({ minLength: 3, maxLength: 20 }).filter(s => s.trim().length > 0),
        fc.string({ minLength: 3, maxLength: 30 }).filter(s => s.trim().length > 0),
        async (hasDisplayName, displayName, fullName) => {
          const record = {
            id: 1,
            payment_method_id: 1,
            cycle_start_date: '2026-01-16',
            cycle_end_date: '2026-02-15',
            is_user_entered: 0,
            actual_statement_balance: 0,
            calculated_statement_balance: 100,
            display_name: hasDisplayName ? displayName : null,
            full_name: fullName
          };

          billingCycleRepository.findUnreviewedAutoGenerated = async () => [record];

          const result = await reminderService.getAutoGeneratedCycleNotifications();

          expect(result.count).toBe(1);
          const expectedName = hasDisplayName ? displayName : fullName;
          expect(result.cycles[0].displayName).toBe(expectedName);
          expect(result.cycles[0].cycleEndDate).toBe('2026-02-15');
        }
      ),
      pbtOptions()
    );
  });

  // --- Property 5 Tests ---

  /**
   * Feature: billing-cycle-automation, Property 5: Billing Cycle Reminder Suppression
   * **Validates: Requirements 4.1**
   * 
   * For any credit card with an auto-generated cycle record for the most recently
   * completed billing period, getBillingCycleReminders should report hasEntry=true
   * for that card, regardless of whether the cycle has been reviewed by the user.
   */
  test('Property 5: Billing Cycle Reminder Suppression — auto-generated cycle suppresses reminder', async () => {
    await fc.assert(
      fc.asyncProperty(
        // billing_cycle_day (1-28 to avoid edge cases)
        fc.integer({ min: 1, max: 28 }),
        // is_user_entered: 0 or 1 (shouldn't matter for hasEntry)
        fc.constantFrom(0, 1),
        // actual_statement_balance: 0 or positive (shouldn't matter for hasEntry)
        fc.oneof(
          fc.constant(0),
          fc.float({ min: Math.fround(0.01), max: Math.fround(5000), noNaN: true })
            .map(n => Math.round(n * 100) / 100)
        ),
        async (billingCycleDay, isUserEntered, actualBalance) => {
          const referenceDate = new Date('2026-02-20');
          const cycleDates = statementBalanceService.calculatePreviousCycleDates(
            billingCycleDay, referenceDate
          );

          const card = {
            id: 1,
            display_name: 'Test Card',
            full_name: 'Test Credit Card',
            billing_cycle_day: billingCycleDay,
            type: 'credit_card',
            is_active: 1,
            payment_due_day: 15
          };

          // Mock: this card needs billing cycle entry check
          billingCycleRepository.getCreditCardsNeedingBillingCycleEntry = async () => [card];

          // Mock: a billing cycle record exists (auto-generated or user-entered)
          billingCycleRepository.findByPaymentMethodAndCycleEnd = async (pmId, endDate) => {
            if (pmId === card.id && endDate === cycleDates.endDate) {
              return {
                id: 1,
                payment_method_id: card.id,
                cycle_start_date: cycleDates.startDate,
                cycle_end_date: cycleDates.endDate,
                is_user_entered: isUserEntered,
                actual_statement_balance: actualBalance,
                calculated_statement_balance: 100
              };
            }
            return null;
          };

          const result = await reminderService.getBillingCycleReminders(referenceDate);

          // The card should report hasEntry=true regardless of is_user_entered or actual_statement_balance
          const cardReminder = result.allCards.find(c => c.paymentMethodId === card.id);
          expect(cardReminder).toBeDefined();
          expect(cardReminder.hasEntry).toBe(true);
          expect(cardReminder.needsEntry).toBe(false);

          // needsEntryCount should be 0 since the entry exists
          expect(result.needsEntryCount).toBe(0);
        }
      ),
      pbtOptions()
    );
  });

  /**
   * Property 5 continued: Without any cycle record, reminder reports hasEntry=false
   * **Validates: Requirements 4.1**
   */
  test('Property 5: Billing Cycle Reminder Suppression — no record means hasEntry=false', async () => {
    await fc.assert(
      fc.asyncProperty(
        fc.integer({ min: 1, max: 28 }),
        async (billingCycleDay) => {
          const referenceDate = new Date('2026-02-20');

          const card = {
            id: 1,
            display_name: 'Test Card',
            full_name: 'Test Credit Card',
            billing_cycle_day: billingCycleDay,
            type: 'credit_card',
            is_active: 1,
            payment_due_day: 15
          };

          billingCycleRepository.getCreditCardsNeedingBillingCycleEntry = async () => [card];

          // No billing cycle record exists
          billingCycleRepository.findByPaymentMethodAndCycleEnd = async () => null;

          const result = await reminderService.getBillingCycleReminders(referenceDate);

          const cardReminder = result.allCards.find(c => c.paymentMethodId === card.id);
          expect(cardReminder).toBeDefined();
          expect(cardReminder.hasEntry).toBe(false);
          expect(cardReminder.needsEntry).toBe(true);

          expect(result.needsEntryCount).toBe(1);
        }
      ),
      pbtOptions()
    );
  });
});
