name: CI

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      health_check_timeout:
        description: 'Health check HTTP timeout in seconds'
        required: false
        default: '30'
        type: string
      health_check_retries:
        description: 'Number of health check retry attempts'
        required: false
        default: '10'
        type: string
      enable_security_scan:
        description: 'Enable security vulnerability scanning'
        required: false
        default: true
        type: boolean

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  backend-unit-tests:
    name: Backend Unit Tests
    runs-on: ubuntu-latest
    if: github.actor != 'dependabot[bot]'
    defaults:
      run:
        working-directory: backend

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Validate test naming conventions
        run: node ../scripts/validate-test-naming.js

      - name: Record test start time
        id: test_start
        run: echo "start=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Run unit tests
        run: npm run test:unit:ci
        env:
          CI: true

      - name: Check runtime budget
        if: always()
        run: |
          ELAPSED=$(( $(date +%s) - ${{ steps.test_start.outputs.start }} ))
          node ../scripts/check-test-budget.js backend-unit-tests $ELAPSED
        env:
          COMMIT_MESSAGE: ${{ github.event.head_commit.message }}

  backend-pbt-shards:
    name: Backend PBT Shard ${{ matrix.shard }}
    runs-on: ubuntu-latest
    if: github.actor != 'dependabot[bot]'
    strategy:
      fail-fast: true
      matrix:
        shard: ['1/3', '2/3', '3/3']
    defaults:
      run:
        working-directory: backend

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Record PBT start time
        id: pbt_start
        run: echo "start=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Run PBT tests (shard ${{ matrix.shard }})
        run: npx cross-env NODE_ENV=test CI=true FAST_CHECK_NUM_RUNS=15 jest --bail --testPathPatterns=pbt --shard=${{ matrix.shard }}

      - name: Check runtime budget
        if: always()
        run: |
          ELAPSED=$(( $(date +%s) - ${{ steps.pbt_start.outputs.start }} ))
          node ../scripts/check-test-budget.js backend-pbt-shard $ELAPSED
        env:
          COMMIT_MESSAGE: ${{ github.event.head_commit.message }}

  backend-pbt-tests:
    name: Backend PBT Tests
    runs-on: ubuntu-latest
    if: always() && github.actor != 'dependabot[bot]'
    needs: backend-pbt-shards
    steps:
      - name: Check shard results
        run: |
          if [ "${{ needs.backend-pbt-shards.result }}" != "success" ]; then
            echo "PBT shards failed or were cancelled"
            exit 1
          fi
          echo "All PBT shards passed"

      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      - name: Validate PBT guardrails
        run: node scripts/validate-pbt-guardrails.js

  frontend-tests:
    name: Frontend Tests
    runs-on: ubuntu-latest
    if: github.actor != 'dependabot[bot]'
    defaults:
      run:
        working-directory: frontend

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Validate test naming conventions
        run: node ../scripts/validate-test-naming.js

      - name: Record test start time
        id: test_start
        run: echo "start=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Run tests
        run: npx vitest --run --exclude '**/App.performance.test.jsx'

      - name: Check runtime budget
        if: always()
        run: |
          ELAPSED=$(( $(date +%s) - ${{ steps.test_start.outputs.start }} ))
          node ../scripts/check-test-budget.js frontend-tests $ELAPSED
        env:
          COMMIT_MESSAGE: ${{ github.event.head_commit.message }}

  test-health-report:
    name: Test Health Report
    runs-on: ubuntu-latest
    if: always() && github.actor != 'dependabot[bot]'
    needs: [backend-unit-tests, backend-pbt-tests, frontend-tests]
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      - name: Report test health
        run: node scripts/report-test-health.js >> $GITHUB_STEP_SUMMARY
        env:
          GITHUB_ACTIONS: true

  build-and-push-ghcr:
    name: Build and Push to GHCR
    runs-on: ubuntu-latest
    needs: [backend-unit-tests, backend-pbt-tests, frontend-tests]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push' && github.actor != 'dependabot[bot]'
    permissions:
      contents: write
      packages: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        run: |
          echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "version=$(jq -r .version backend/package.json)" >> $GITHUB_OUTPUT
          echo "build_date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT
      
      - name: Build and push to GHCR
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/expense-tracker:${{ steps.meta.outputs.sha_short }}
            ghcr.io/${{ github.repository_owner }}/expense-tracker:v${{ steps.meta.outputs.version }}
          build-args: |
            IMAGE_TAG=${{ steps.meta.outputs.sha_short }}
            BUILD_DATE=${{ steps.meta.outputs.build_date }}
            GIT_COMMIT=${{ steps.meta.outputs.sha_short }}
          labels: |
            org.opencontainers.image.created=${{ steps.meta.outputs.build_date }}
            org.opencontainers.image.version=${{ steps.meta.outputs.version }}
            org.opencontainers.image.revision=${{ steps.meta.outputs.sha_short }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.title=expense-tracker
            org.opencontainers.image.description=Personal expense tracking application
          annotations: |
            org.opencontainers.image.created=${{ steps.meta.outputs.build_date }}
            org.opencontainers.image.version=${{ steps.meta.outputs.version }}
            org.opencontainers.image.revision=${{ steps.meta.outputs.sha_short }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Prepare docker-compose for release
        run: |
          # Create a version-specific docker-compose file
          sed "s/{owner}/${{ github.repository_owner }}/g; s/:latest/:v${{ steps.meta.outputs.version }}/g" \
            docker-compose.ghcr.yml > docker-compose-v${{ steps.meta.outputs.version }}.yml
      
      - name: Check if release exists
        id: check_release
        run: |
          if gh release view "v${{ steps.meta.outputs.version }}" &>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Create or update release
        run: |
          if [ "${{ steps.check_release.outputs.exists }}" = "true" ]; then
            echo "Release v${{ steps.meta.outputs.version }} already exists, uploading asset..."
            gh release upload "v${{ steps.meta.outputs.version }}" \
              docker-compose-v${{ steps.meta.outputs.version }}.yml \
              --clobber
          else
            echo "Creating new release v${{ steps.meta.outputs.version }}..."
            echo "## Pre-Built Container Image Available" > release_notes.md
            echo "" >> release_notes.md
            echo "This release is available as a pre-built Docker image at GitHub Container Registry." >> release_notes.md
            echo "" >> release_notes.md
            echo "### Quick Start" >> release_notes.md
            echo "" >> release_notes.md
            echo "Download the docker-compose file:" >> release_notes.md
            echo "https://github.com/${{ github.repository }}/releases/download/v${{ steps.meta.outputs.version }}/docker-compose-v${{ steps.meta.outputs.version }}.yml" >> release_notes.md
            echo "" >> release_notes.md
            echo "Then run: docker-compose -f docker-compose-v${{ steps.meta.outputs.version }}.yml up -d" >> release_notes.md
            echo "" >> release_notes.md
            echo "### Container Images" >> release_notes.md
            echo "" >> release_notes.md
            echo "- ghcr.io/${{ github.repository_owner }}/expense-tracker:v${{ steps.meta.outputs.version }} (this release)" >> release_notes.md
            echo "- ghcr.io/${{ github.repository_owner }}/expense-tracker:${{ steps.meta.outputs.sha_short }} (commit SHA)" >> release_notes.md
            echo "- ghcr.io/${{ github.repository_owner }}/expense-tracker:latest (latest main)" >> release_notes.md
            echo "" >> release_notes.md
            echo "See CHANGELOG.md for detailed changes." >> release_notes.md
            
            gh release create "v${{ steps.meta.outputs.version }}" \
              docker-compose-v${{ steps.meta.outputs.version }}.yml \
              --title "Release v${{ steps.meta.outputs.version }}" \
              --notes-file release_notes.md
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  deployment-health-check:
    name: Deployment Health Check
    runs-on: ubuntu-latest
    needs: [build-and-push-ghcr]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push' && github.actor != 'dependabot[bot]'
    permissions:
      packages: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract image metadata
        id: meta
        run: |
          echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "image=ghcr.io/${{ github.repository_owner }}/expense-tracker:$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Store previous deployment SHA
        id: previous
        run: |
          REGISTRY="ghcr.io/${{ github.repository_owner }}"
          IMAGE_NAME="expense-tracker"
          CURRENT_SHA="${{ steps.meta.outputs.sha_short }}"

          # Query GHCR for the latest tag that isn't the current SHA
          # Use docker manifest inspect to check if a 'latest' image exists
          PREVIOUS_SHA="none"
          if docker pull "$REGISTRY/$IMAGE_NAME:latest" 2>/dev/null; then
            # Get the digest of the latest image
            LATEST_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$REGISTRY/$IMAGE_NAME:latest" 2>/dev/null || echo "")
            if [ -n "$LATEST_DIGEST" ]; then
              PREVIOUS_SHA="latest"
              echo "Found previous deployment at :latest tag"
            fi
          else
            echo "No previous deployment found at :latest tag"
          fi

          echo "previous_sha=$PREVIOUS_SHA" >> $GITHUB_OUTPUT
          echo "registry=$REGISTRY" >> $GITHUB_OUTPUT
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "Previous deployment SHA: $PREVIOUS_SHA"

      - name: Pull deployed Docker image
        run: docker pull "${{ steps.meta.outputs.image }}"

      - name: Start container
        run: |
          docker run -d \
            --name expense-tracker-health-check \
            -p 2424:2424 \
            -e NODE_ENV=production \
            -e LOG_LEVEL=info \
            "${{ steps.meta.outputs.image }}"

      - name: Wait for container initialization
        run: sleep 10

      - name: Make health check script executable
        run: chmod +x scripts/health-check.sh

      - name: Run backend health check
        id: backend_health
        run: |
          RETRIES=${{ inputs.health_check_retries || '10' }}
          TIMEOUT=${{ inputs.health_check_timeout || '30' }}
          ./scripts/health-check.sh http://localhost:2424/api/health "$RETRIES" 3 "$TIMEOUT"
        continue-on-error: true

      - name: Run frontend health check
        id: frontend_health
        run: |
          RETRIES=${{ inputs.health_check_retries || '10' }}
          TIMEOUT=${{ inputs.health_check_timeout || '30' }}
          ./scripts/health-check.sh http://localhost:2424/ "$RETRIES" 3 "$TIMEOUT"
        continue-on-error: true

      - name: Report health check results
        if: always()
        run: |
          echo "## Deployment Health Check Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** \`${{ steps.meta.outputs.image }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.backend_health.outcome }}" = "success" ]; then
            echo "✅ Backend health check: **PASSED**" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ Backend health check: **FAILED**" >> $GITHUB_STEP_SUMMARY
          fi
          if [ "${{ steps.frontend_health.outcome }}" = "success" ]; then
            echo "✅ Frontend health check: **PASSED**" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ Frontend health check: **FAILED**" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Collect container logs on failure
        if: steps.backend_health.outcome == 'failure' || steps.frontend_health.outcome == 'failure'
        run: |
          echo "::group::Container logs"
          docker logs expense-tracker-health-check 2>&1 || true
          echo "::endgroup::"
          echo ""
          echo "::group::Container status"
          docker inspect expense-tracker-health-check --format='{{.State.Status}}' || true
          echo "::endgroup::"

      - name: Stop container
        if: always()
        run: |
          docker stop expense-tracker-health-check || true
          docker rm expense-tracker-health-check || true

      - name: Initiate rollback on health check failure
        id: rollback
        if: steps.backend_health.outcome == 'failure' || steps.frontend_health.outcome == 'failure'
        run: |
          ROLLBACK_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          echo "::warning::[$ROLLBACK_TIMESTAMP] Health checks failed, initiating rollback"
          echo "  Failed SHA: ${{ steps.meta.outputs.sha_short }}"
          echo "  Previous SHA: ${{ steps.previous.outputs.previous_sha }}"
          echo "  Backend: ${{ steps.backend_health.outcome }}"
          echo "  Frontend: ${{ steps.frontend_health.outcome }}"

          if [ "${{ steps.previous.outputs.previous_sha }}" = "none" ]; then
            echo "::error::[$ROLLBACK_TIMESTAMP] No previous deployment available for rollback"
            echo "rollback_result=no_previous" >> $GITHUB_OUTPUT
            exit 1
          fi

          chmod +x scripts/rollback.sh
          ./scripts/rollback.sh \
            "${{ steps.previous.outputs.previous_sha }}" \
            "${{ steps.previous.outputs.registry }}" \
            "${{ steps.previous.outputs.image_name }}" \
            "expense-tracker-health-check"

          echo "rollback_result=deployed" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Run health checks on rolled-back deployment
        id: rollback_health
        if: steps.rollback.outcome == 'success' && steps.rollback.outputs.rollback_result == 'deployed'
        run: |
          ROLLBACK_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          echo "[$ROLLBACK_TIMESTAMP] Running health checks on rolled-back deployment..."

          chmod +x scripts/health-check.sh
          BACKEND_OK=true
          FRONTEND_OK=true

          ./scripts/health-check.sh http://localhost:2424/api/health 5 3 30 || BACKEND_OK=false
          ./scripts/health-check.sh http://localhost:2424/ 5 3 30 || FRONTEND_OK=false

          COMPLETION_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          if [ "$BACKEND_OK" = "true" ] && [ "$FRONTEND_OK" = "true" ]; then
            echo "[$COMPLETION_TIMESTAMP] ✓ Rollback health checks passed"
            echo "rollback_health=passed" >> $GITHUB_OUTPUT
          else
            echo "[$COMPLETION_TIMESTAMP] ✗ Rollback health checks failed"
            echo "  Backend: $BACKEND_OK, Frontend: $FRONTEND_OK"
            echo "rollback_health=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
        continue-on-error: true

      - name: Report rollback results
        if: steps.rollback.outcome == 'success' || steps.rollback.outcome == 'failure'
        run: |
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Rollback Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** Health check failure for SHA \`${{ steps.meta.outputs.sha_short }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Previous SHA:** \`${{ steps.previous.outputs.previous_sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $TIMESTAMP" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.rollback.outputs.rollback_result }}" = "no_previous" ]; then
            echo "❌ Rollback: **SKIPPED** (no previous deployment available)" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.rollback_health.outputs.rollback_health }}" = "passed" ]; then
            echo "✅ Rollback: **SUCCESSFUL**" >> $GITHUB_STEP_SUMMARY
            echo "✅ Rollback health checks: **PASSED**" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ Rollback: **FAILED**" >> $GITHUB_STEP_SUMMARY
            echo "⚠️ **Manual intervention required**" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Generate deployment metadata
        id: deployment_metadata
        if: always()
        run: |
          DEPLOY_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          VERSION=$(jq -r .version backend/package.json)

          # Determine deployment status
          if [ "${{ steps.backend_health.outcome }}" = "success" ] && [ "${{ steps.frontend_health.outcome }}" = "success" ]; then
            DEPLOY_STATUS="success"
          elif [ "${{ steps.rollback_health.outputs.rollback_health }}" = "passed" ]; then
            DEPLOY_STATUS="rolled_back"
          else
            DEPLOY_STATUS="failed"
          fi

          # Determine health check results
          BACKEND_HEALTH="failed"
          FRONTEND_HEALTH="failed"
          [ "${{ steps.backend_health.outcome }}" = "success" ] && BACKEND_HEALTH="passed"
          [ "${{ steps.frontend_health.outcome }}" = "success" ] && FRONTEND_HEALTH="passed"

          # Build metadata JSON
          METADATA=$(cat <<EOF
          {
            "sha": "${{ steps.meta.outputs.sha_short }}",
            "timestamp": "$DEPLOY_TIMESTAMP",
            "environment": "production",
            "version": "$VERSION",
            "status": "$DEPLOY_STATUS",
            "healthChecks": {
              "backend": "$BACKEND_HEALTH",
              "frontend": "$FRONTEND_HEALTH"
            }
          }
          EOF
          )

          # Add rollback info if applicable
          if [ "$DEPLOY_STATUS" = "rolled_back" ]; then
            METADATA=$(echo "$METADATA" | jq --arg prevSha "${{ steps.previous.outputs.previous_sha }}" \
              --arg reason "Health check failure" \
              --arg ts "$DEPLOY_TIMESTAMP" \
              '. + { rollbackInfo: { previousSha: $prevSha, reason: $reason, timestamp: $ts } }')
          fi

          echo "$METADATA" > deployment-record.json
          echo "Deployment metadata generated:"
          cat deployment-record.json

          echo "deploy_status=$DEPLOY_STATUS" >> $GITHUB_OUTPUT

      - name: Upload deployment record
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-${{ steps.meta.outputs.sha_short }}
          path: deployment-record.json
          retention-days: 30

      - name: Report deployment state in summary
        if: always()
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment State" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** \`${{ steps.deployment_metadata.outputs.deploy_status }}\`" >> $GITHUB_STEP_SUMMARY
          if [ -f deployment-record.json ]; then
            echo '```json' >> $GITHUB_STEP_SUMMARY
            cat deployment-record.json >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

      - name: Fail on health check failure
        if: steps.backend_health.outcome == 'failure' || steps.frontend_health.outcome == 'failure'
        run: |
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          echo "::error::[$TIMESTAMP] Deployment health checks failed for SHA ${{ steps.meta.outputs.sha_short }}"

          if [ "${{ steps.rollback_health.outputs.rollback_health }}" = "passed" ]; then
            echo "Rollback to ${{ steps.previous.outputs.previous_sha }} was successful"
          elif [ "${{ steps.rollback.outputs.rollback_result }}" = "no_previous" ]; then
            echo "::error::No previous deployment available for rollback - manual intervention required"
          else
            echo "::error::[$TIMESTAMP] Rollback also failed - manual intervention required"
            echo "::error::HALT: All automated recovery actions exhausted"
          fi
          exit 1
