name: CI

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  backend-unit-tests:
    name: Backend Unit Tests
    runs-on: ubuntu-latest
    if: github.actor != 'dependabot[bot]'
    defaults:
      run:
        working-directory: backend

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:unit:ci
        env:
          CI: true

  backend-pbt-shards:
    name: Backend PBT Shard ${{ matrix.shard }}
    runs-on: ubuntu-latest
    if: github.actor != 'dependabot[bot]'
    strategy:
      fail-fast: true
      matrix:
        shard: ['1/3', '2/3', '3/3']
    defaults:
      run:
        working-directory: backend

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Run PBT tests (shard ${{ matrix.shard }})
        run: npx cross-env NODE_ENV=test CI=true FAST_CHECK_NUM_RUNS=15 jest --bail --testPathPatterns=pbt --shard=${{ matrix.shard }}

  backend-pbt-tests:
    name: Backend PBT Tests
    runs-on: ubuntu-latest
    if: always() && github.actor != 'dependabot[bot]'
    needs: backend-pbt-shards
    steps:
      - name: Check shard results
        run: |
          if [ "${{ needs.backend-pbt-shards.result }}" != "success" ]; then
            echo "PBT shards failed or were cancelled"
            exit 1
          fi
          echo "All PBT shards passed"

  frontend-tests:
    name: Frontend Tests
    runs-on: ubuntu-latest
    if: github.actor != 'dependabot[bot]'
    defaults:
      run:
        working-directory: frontend

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npx vitest --run --exclude '**/App.performance.test.jsx'

  build-and-push-ghcr:
    name: Build and Push to GHCR
    runs-on: ubuntu-latest
    needs: [backend-unit-tests, backend-pbt-tests, frontend-tests]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push' && github.actor != 'dependabot[bot]'
    permissions:
      contents: write
      packages: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        run: |
          echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "version=$(jq -r .version backend/package.json)" >> $GITHUB_OUTPUT
          echo "build_date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT
      
      - name: Build and push to GHCR
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/expense-tracker:${{ steps.meta.outputs.sha_short }}
            ghcr.io/${{ github.repository_owner }}/expense-tracker:latest
            ghcr.io/${{ github.repository_owner }}/expense-tracker:v${{ steps.meta.outputs.version }}
          build-args: |
            IMAGE_TAG=${{ steps.meta.outputs.sha_short }}
            BUILD_DATE=${{ steps.meta.outputs.build_date }}
            GIT_COMMIT=${{ steps.meta.outputs.sha_short }}
          labels: |
            org.opencontainers.image.created=${{ steps.meta.outputs.build_date }}
            org.opencontainers.image.version=${{ steps.meta.outputs.version }}
            org.opencontainers.image.revision=${{ steps.meta.outputs.sha_short }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.title=expense-tracker
            org.opencontainers.image.description=Personal expense tracking application
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Prepare docker-compose for release
        run: |
          # Create a version-specific docker-compose file
          sed "s/{owner}/${{ github.repository_owner }}/g; s/:latest/:v${{ steps.meta.outputs.version }}/g" \
            docker-compose.ghcr.yml > docker-compose-v${{ steps.meta.outputs.version }}.yml
      
      - name: Check if release exists
        id: check_release
        run: |
          if gh release view "v${{ steps.meta.outputs.version }}" &>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Create or update release
        run: |
          if [ "${{ steps.check_release.outputs.exists }}" = "true" ]; then
            echo "Release v${{ steps.meta.outputs.version }} already exists, uploading asset..."
            gh release upload "v${{ steps.meta.outputs.version }}" \
              docker-compose-v${{ steps.meta.outputs.version }}.yml \
              --clobber
          else
            echo "Creating new release v${{ steps.meta.outputs.version }}..."
            cat > release_notes.md <<'NOTES_EOF'
## ðŸš€ Recommended: Use Pre-Built Container Image

This release is available as a pre-built, tested Docker image. Using the container image is the recommended deployment method - no build required!

### Quick Start (Recommended)

Download and start:
```bash
wget https://github.com/REPO_PLACEHOLDER/releases/download/VERSION_PLACEHOLDER/docker-compose-VERSION_PLACEHOLDER.yml
docker-compose -f docker-compose-VERSION_PLACEHOLDER.yml up -d
```

### Available Container Images

- `ghcr.io/OWNER_PLACEHOLDER/expense-tracker:VERSION_PLACEHOLDER` - This release (recommended)
- `ghcr.io/OWNER_PLACEHOLDER/expense-tracker:SHA_PLACEHOLDER` - Commit SHA (immutable)
- `ghcr.io/OWNER_PLACEHOLDER/expense-tracker:latest` - Latest main branch

### ðŸ“¦ Assets

- docker-compose-VERSION_PLACEHOLDER.yml - Ready-to-use Docker Compose configuration
- Source code archives - For reference only; use container image for deployment

### ðŸ“ What's Changed

See [CHANGELOG.md](https://github.com/REPO_PLACEHOLDER/blob/main/CHANGELOG.md) for detailed changes.
NOTES_EOF
            sed -i "s|REPO_PLACEHOLDER|${{ github.repository }}|g" release_notes.md
            sed -i "s|VERSION_PLACEHOLDER|v${{ steps.meta.outputs.version }}|g" release_notes.md
            sed -i "s|OWNER_PLACEHOLDER|${{ github.repository_owner }}|g" release_notes.md
            sed -i "s|SHA_PLACEHOLDER|${{ steps.meta.outputs.sha_short }}|g" release_notes.md
            
            gh release create "v${{ steps.meta.outputs.version }}" \
              docker-compose-v${{ steps.meta.outputs.version }}.yml \
              --title "Release v${{ steps.meta.outputs.version }}" \
              --notes-file release_notes.md
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
