/**
 * Property-Based Tests for BillingCycleHistoryService Chronological Processing Order
 * Feature: billing-cycle-payment-deduction
 * 
 * Using fast-check library for property-based testing
 * 
 * **Validates: Requirements 2.6**
 */

const fc = require('fast-check');
const { pbtOptions } = require('../test/pbtArbitraries');

// Mock the database module before requiring the service
jest.mock('../database/db', () => ({
  getDatabase: jest.fn()
}));

// Mock the billing cycle repository
jest.mock('../repositories/billingCycleRepository');

// Mock the payment method repository
jest.mock('../repositories/paymentMethodRepository');

// Mock the statement balance service
jest.mock('./statementBalanceService');

// Mock activityLogService (imported by the service)
jest.mock('./activityLogService');

const { getDatabase } = require('../database/db');
const billingCycleRepository = require('../repositories/billingCycleRepository');
const statementBalanceService = require('./statementBalanceService');
const billingCycleHistoryService = require('./billingCycleHistoryService');

describe('BillingCycleHistoryService - Chronological Processing Order (Property 3)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  /**
   * Helper: generate N consecutive monthly billing cycle periods (oldest-first).
   * Returns periods as { startDate, endDate } strings in YYYY-MM-DD format.
   */
  function generatePeriods(count, billingCycleDay, baseYear, baseMonth) {
    const periods = [];
    for (let i = 0; i < count; i++) {
      const monthOffset = i;
      // End date: billingCycleDay of (baseMonth + monthOffset)
      const endMonth = baseMonth + monthOffset;
      const endYear = baseYear + Math.floor((endMonth - 1) / 12);
      const endMon = ((endMonth - 1) % 12) + 1;
      const daysInEndMonth = new Date(endYear, endMon, 0).getDate();
      const endDay = Math.min(billingCycleDay, daysInEndMonth);
      const endDate = `${endYear}-${String(endMon).padStart(2, '0')}-${String(endDay).padStart(2, '0')}`;

      // Start date: day after previous cycle's end date
      let startDate;
      if (i === 0) {
        // First period: start is day after the end of the "month before"
        const prevEndMonth = endMonth - 1;
        const prevEndYear = baseYear + Math.floor((prevEndMonth - 1) / 12);
        const prevEndMon = ((prevEndMonth - 1) % 12) + 1;
        const daysInPrevMonth = new Date(prevEndYear, prevEndMon, 0).getDate();
        const prevEndDay = Math.min(billingCycleDay, daysInPrevMonth);
        const prevEnd = new Date(prevEndYear, prevEndMon - 1, prevEndDay);
        prevEnd.setDate(prevEnd.getDate() + 1);
        startDate = prevEnd.toISOString().split('T')[0];
      } else {
        // Subsequent periods: day after previous period's end date
        const prevEnd = new Date(periods[i - 1].endDate + 'T00:00:00');
        prevEnd.setDate(prevEnd.getDate() + 1);
        startDate = prevEnd.toISOString().split('T')[0];
      }

      periods.push({ startDate, endDate });
    }
    return periods;
  }

  /**
   * Feature: billing-cycle-payment-deduction, Property 3: Chronological Processing Order
   * **Validates: Requirements 2.6**
   *
   * For any set of N missing billing cycle periods auto-generated by the history service,
   * the cycles SHALL be processed in chronological order (oldest first), such that
   * cycle K's previous balance is derived from cycle K-1's calculated balance
   * (or the pre-existing cycle before the batch, for K=0).
   */
  test('Property 3: Cycles are generated in chronological order (oldest first)', async () => {
    await fc.assert(
      fc.asyncProperty(
        // Number of missing periods to generate (2-6)
        fc.integer({ min: 2, max: 6 }),
        // Billing cycle day (1-28 to avoid month-end edge cases)
        fc.integer({ min: 1, max: 28 }),
        // Per-period expense amounts (array of 6, we'll slice to count)
        fc.array(
          fc.float({ min: Math.fround(0), max: Math.fround(5000), noNaN: true })
            .map(n => Math.round(n * 100) / 100),
          { minLength: 6, maxLength: 6 }
        ),
        // Per-period payment amounts
        fc.array(
          fc.float({ min: Math.fround(0), max: Math.fround(3000), noNaN: true })
            .map(n => Math.round(n * 100) / 100),
          { minLength: 6, maxLength: 6 }
        ),
        // Previous cycle effective balance (before the batch)
        fc.float({ min: Math.fround(0), max: Math.fround(10000), noNaN: true })
          .map(n => Math.round(n * 100) / 100),
        async (count, billingCycleDay, expenseAmounts, paymentAmounts, preBatchBalance) => {
          const paymentMethodId = 1;
          const periods = generatePeriods(count, billingCycleDay, 2024, 1);

          // getMissingCyclePeriods returns newest-first; the service reverses it
          const newestFirstPeriods = [...periods].reverse();

          // Track created cycles in order
          const createdCycles = [];

          // Mock findByPaymentMethod to return no existing cycles
          billingCycleRepository.findByPaymentMethod.mockResolvedValue([]);

          // Mock getMissingCyclePeriods on the service prototype to return our controlled periods
          // We need to mock the internal call, so we spy on the method
          const getMissingSpy = jest.spyOn(billingCycleHistoryService, 'getMissingCyclePeriods')
            .mockResolvedValue(newestFirstPeriods);

          // Mock findPreviousCycle - returns the pre-batch cycle for the first period
          billingCycleRepository.findPreviousCycle.mockResolvedValue(
            preBatchBalance > 0
              ? { actual_statement_balance: preBatchBalance, calculated_statement_balance: 0, is_user_entered: 1 }
              : null
          );

          // Mock create to capture cycles in creation order
          billingCycleRepository.create.mockImplementation(async (data) => {
            const cycle = { id: createdCycles.length + 1, ...data };
            createdCycles.push(cycle);
            return cycle;
          });

          // Track which period index each db.get call corresponds to
          let dbGetCallIndex = 0;
          const mockDb = {
            get: jest.fn((sql, params, callback) => {
              // Determine which period this call is for based on call order
              // Each period makes 2 calls: expenses then payments
              const periodIndex = Math.floor(dbGetCallIndex / 2);
              const isExpenseQuery = dbGetCallIndex % 2 === 0;
              dbGetCallIndex++;

              if (isExpenseQuery) {
                callback(null, { total: expenseAmounts[periodIndex] || 0 });
              } else {
                callback(null, { total: paymentAmounts[periodIndex] || 0 });
              }
            })
          };
          getDatabase.mockResolvedValue(mockDb);

          // Call autoGenerateBillingCycles
          const result = await billingCycleHistoryService.autoGenerateBillingCycles(
            paymentMethodId,
            billingCycleDay,
            new Date('2024-12-15')
          );

          // ASSERTION 1: Cycles are created in chronological order (oldest first)
          expect(createdCycles.length).toBe(count);
          for (let i = 1; i < createdCycles.length; i++) {
            const prevEnd = createdCycles[i - 1].cycle_end_date;
            const currEnd = createdCycles[i].cycle_end_date;
            expect(prevEnd < currEnd).toBe(true);
          }

          // ASSERTION 2: Each cycle's balance uses the previous cycle's calculated balance as carry-forward
          let expectedPrevBalance = preBatchBalance;
          for (let i = 0; i < createdCycles.length; i++) {
            const expenses = expenseAmounts[i] || 0;
            const payments = paymentAmounts[i] || 0;
            const expectedBalance = Math.max(0, Math.round((expectedPrevBalance + expenses - payments) * 100) / 100);

            expect(createdCycles[i].calculated_statement_balance).toBe(expectedBalance);

            // Next cycle's carry-forward is this cycle's calculated balance
            expectedPrevBalance = expectedBalance;
          }

          // ASSERTION 3: Return value matches created cycles
          expect(result.length).toBe(count);

          // Cleanup
          getMissingSpy.mockRestore();
        }
      ),
      pbtOptions()
    );
  });

  /**
   * Property 3 edge case: carry-forward chain resets to zero when payments exceed balance
   * **Validates: Requirements 2.6**
   *
   * When a cycle's payments exceed its carry-forward + expenses (floored at zero),
   * the next cycle in the chain should use zero as its previous balance.
   */
  test('Property 3: Carry-forward chain correctly floors at zero mid-batch', async () => {
    await fc.assert(
      fc.asyncProperty(
        // Billing cycle day
        fc.integer({ min: 1, max: 28 }),
        // Initial balance before batch
        fc.float({ min: Math.fround(0), max: Math.fround(5000), noNaN: true })
          .map(n => Math.round(n * 100) / 100),
        // Expenses for cycle 1 (small)
        fc.float({ min: Math.fround(0), max: Math.fround(100), noNaN: true })
          .map(n => Math.round(n * 100) / 100),
        // Overpayment for cycle 1 (large, to force floor-at-zero)
        fc.float({ min: Math.fround(100), max: Math.fround(20000), noNaN: true })
          .map(n => Math.round(n * 100) / 100),
        // Expenses for cycle 2
        fc.float({ min: Math.fround(0.01), max: Math.fround(5000), noNaN: true })
          .map(n => Math.round(n * 100) / 100),
        async (billingCycleDay, initialBalance, expenses1, overpayment1, expenses2) => {
          const paymentMethodId = 1;
          const periods = generatePeriods(2, billingCycleDay, 2024, 3);
          const newestFirstPeriods = [...periods].reverse();

          const createdCycles = [];

          billingCycleRepository.findByPaymentMethod.mockResolvedValue([]);

          const getMissingSpy = jest.spyOn(billingCycleHistoryService, 'getMissingCyclePeriods')
            .mockResolvedValue(newestFirstPeriods);

          billingCycleRepository.findPreviousCycle.mockResolvedValue(
            initialBalance > 0
              ? { actual_statement_balance: initialBalance, calculated_statement_balance: 0, is_user_entered: 1 }
              : null
          );

          billingCycleRepository.create.mockImplementation(async (data) => {
            const cycle = { id: createdCycles.length + 1, ...data };
            createdCycles.push(cycle);
            return cycle;
          });

          // Cycle 1: small expenses, large payment → floors at zero
          // Cycle 2: some expenses, no payments → balance = 0 + expenses2
          const perPeriodData = [
            { expenses: expenses1, payments: initialBalance + expenses1 + overpayment1 },
            { expenses: expenses2, payments: 0 }
          ];

          let dbGetCallIndex = 0;
          const mockDb = {
            get: jest.fn((sql, params, callback) => {
              const periodIndex = Math.floor(dbGetCallIndex / 2);
              const isExpenseQuery = dbGetCallIndex % 2 === 0;
              dbGetCallIndex++;

              if (isExpenseQuery) {
                callback(null, { total: perPeriodData[periodIndex].expenses });
              } else {
                callback(null, { total: perPeriodData[periodIndex].payments });
              }
            })
          };
          getDatabase.mockResolvedValue(mockDb);

          await billingCycleHistoryService.autoGenerateBillingCycles(
            paymentMethodId,
            billingCycleDay,
            new Date('2024-12-15')
          );

          expect(createdCycles.length).toBe(2);

          // Cycle 1 should be floored at zero
          expect(createdCycles[0].calculated_statement_balance).toBe(0);

          // Cycle 2 should use 0 as carry-forward (from floored cycle 1)
          const expectedCycle2 = Math.max(0, Math.round((0 + expenses2 - 0) * 100) / 100);
          expect(createdCycles[1].calculated_statement_balance).toBe(expectedCycle2);

          getMissingSpy.mockRestore();
        }
      ),
      pbtOptions()
    );
  });
});
