// Mock dependencies
jest.mock('../services/billingCycleHistoryService');
jest.mock('../services/paymentMethodService', () => ({
  getCreditCardWithComputedFields: jest.fn()
}));
jest.mock('../repositories/paymentMethodRepository', () => ({
  findById: jest.fn()
}));
jest.mock('../repositories/creditCardPaymentRepository', () => ({
  findByPaymentMethodId: jest.fn()
}));
jest.mock('../services/statementBalanceService', () => ({
  calculateStatementBalance: jest.fn()
}));
jest.mock('../services/activityLogService', () => ({
  logEvent: jest.fn().mockResolvedValue(undefined)
}));
jest.mock('../config/logger', () => ({
  debug: jest.fn(),
  info: jest.fn(),
  warn: jest.fn(),
  error: jest.fn()
}));
jest.mock('../config/paths', () => ({
  getStatementsPath: jest.fn().mockReturnValue('/mock/statements')
}));
jest.mock('fs', () => ({
  existsSync: jest.fn().mockReturnValue(true),
  mkdirSync: jest.fn(),
  writeFileSync: jest.fn(),
  unlinkSync: jest.fn(),
  createReadStream: jest.fn()
}));
jest.mock('../repositories/billingCycleRepository', () => ({
  findById: jest.fn()
}));
jest.mock('../database/db', () => ({
  getDatabase: jest.fn()
}));

const billingCycleController = require('./billingCycleController');
const paymentMethodService = require('../services/paymentMethodService');
const paymentMethodRepository = require('../repositories/paymentMethodRepository');
const creditCardPaymentRepository = require('../repositories/creditCardPaymentRepository');
const statementBalanceService = require('../services/statementBalanceService');
const billingCycleHistoryService = require('../services/billingCycleHistoryService');

/**
 * Unit Tests for getCreditCardDetail unified endpoint
 * 
 * Validates: Requirements 2.1, 2.2, 2.3, 2.4, 2.5, 2.7
 */
describe('billingCycleController.getCreditCardDetail', () => {
  let req, res;

  const mockCardDetails = {
    id: 1,
    display_name: 'Visa',
    full_name: 'Visa Infinite',
    type: 'credit_card',
    current_balance: 500,
    credit_limit: 5000,
    billing_cycle_day: 15,
    payment_due_day: 5,
    is_active: true,
    utilization_percentage: 10,
    days_until_due: 12,
    statement_balance: 450,
    expense_count: 8,
    current_cycle: { start_date: '2026-01-16', end_date: '2026-02-15', transaction_count: 3, total_amount: 200, payment_count: 1, payment_total: 100 },
    has_pending_expenses: false,
    projected_balance: 600
  };

  const mockPayments = [
    { id: 1, payment_method_id: 1, amount: 100, payment_date: '2026-02-01', notes: null, created_at: '2026-02-01T10:00:00Z' }
  ];

  const mockStatementBalance = {
    statementBalance: 450,
    cycleStartDate: '2025-12-16',
    cycleEndDate: '2026-01-15',
    totalExpenses: 500,
    totalPayments: 50,
    isPaid: false
  };

  const mockCycleStatus = {
    cycleStartDate: '2026-01-16',
    cycleEndDate: '2026-02-15',
    calculatedBalance: 200,
    hasActualBalance: false,
    actualBalance: null
  };

  const mockUnifiedCycles = {
    billingCycles: [
      { id: 10, payment_method_id: 1, cycle_start_date: '2026-01-16', cycle_end_date: '2026-02-15', effective_balance: 200, balance_type: 'calculated', transaction_count: 3 }
    ],
    autoGeneratedCount: 0,
    totalCount: 1
  };

  beforeEach(() => {
    jest.clearAllMocks();
    req = { params: { id: '1' }, query: {} };
    res = { status: jest.fn().mockReturnThis(), json: jest.fn().mockReturnThis() };
  });

  test('returns 404 for non-existent payment method', async () => {
    paymentMethodService.getCreditCardWithComputedFields.mockResolvedValue(null);
    paymentMethodRepository.findById.mockResolvedValue(null);

    await billingCycleController.getCreditCardDetail(req, res);

    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({ error: 'Payment method not found' });
  });

  test('returns 400 for non-credit-card payment method', async () => {
    paymentMethodService.getCreditCardWithComputedFields.mockResolvedValue(null);
    paymentMethodRepository.findById.mockResolvedValue({ id: 1, type: 'debit', display_name: 'Debit' });

    await billingCycleController.getCreditCardDetail(req, res);

    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.json).toHaveBeenCalledWith({ error: 'Payment method is not a credit card' });
  });

  test('returns 400 for invalid ID', async () => {
    req.params.id = 'abc';

    await billingCycleController.getCreditCardDetail(req, res);

    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.json).toHaveBeenCalledWith({ error: 'Invalid payment method ID' });
  });

  test('returns successful response with all sections populated', async () => {
    paymentMethodService.getCreditCardWithComputedFields.mockResolvedValue(mockCardDetails);
    creditCardPaymentRepository.findByPaymentMethodId.mockResolvedValue(mockPayments);
    statementBalanceService.calculateStatementBalance.mockResolvedValue(mockStatementBalance);
    billingCycleHistoryService.getCurrentCycleStatus.mockResolvedValue(mockCycleStatus);
    billingCycleHistoryService.getUnifiedBillingCycles.mockResolvedValue(mockUnifiedCycles);

    await billingCycleController.getCreditCardDetail(req, res);

    expect(res.status).toHaveBeenCalledWith(200);
    const body = res.json.mock.calls[0][0];
    expect(body.cardDetails).toEqual(mockCardDetails);
    expect(body.payments).toEqual(mockPayments);
    expect(body.statementBalanceInfo).toEqual(mockStatementBalance);
    expect(body.currentCycleStatus).toEqual(mockCycleStatus);
    expect(body.billingCycles).toEqual(mockUnifiedCycles.billingCycles);
    expect(body.errors).toEqual([]);
  });

  test('returns partial failure with errors array when sub-query fails', async () => {
    paymentMethodService.getCreditCardWithComputedFields.mockResolvedValue(mockCardDetails);
    creditCardPaymentRepository.findByPaymentMethodId.mockResolvedValue(mockPayments);
    statementBalanceService.calculateStatementBalance.mockRejectedValue(new Error('DB timeout'));
    billingCycleHistoryService.getCurrentCycleStatus.mockResolvedValue(mockCycleStatus);
    billingCycleHistoryService.getUnifiedBillingCycles.mockResolvedValue(mockUnifiedCycles);

    await billingCycleController.getCreditCardDetail(req, res);

    expect(res.status).toHaveBeenCalledWith(200);
    const body = res.json.mock.calls[0][0];
    expect(body.payments).toEqual(mockPayments);
    expect(body.statementBalanceInfo).toBeNull();
    expect(body.currentCycleStatus).toEqual(mockCycleStatus);
    expect(body.billingCycles).toEqual(mockUnifiedCycles.billingCycles);
    expect(body.errors).toHaveLength(1);
    expect(body.errors[0].section).toBe('statementBalance');
    expect(body.errors[0].message).toBe('DB timeout');
  });

  test('passes billingCycleLimit query parameter through', async () => {
    req.query.billingCycleLimit = '6';
    paymentMethodService.getCreditCardWithComputedFields.mockResolvedValue(mockCardDetails);
    creditCardPaymentRepository.findByPaymentMethodId.mockResolvedValue([]);
    statementBalanceService.calculateStatementBalance.mockResolvedValue(null);
    billingCycleHistoryService.getCurrentCycleStatus.mockResolvedValue(null);
    billingCycleHistoryService.getUnifiedBillingCycles.mockResolvedValue({ billingCycles: [], autoGeneratedCount: 0, totalCount: 0 });

    await billingCycleController.getCreditCardDetail(req, res);

    expect(billingCycleHistoryService.getUnifiedBillingCycles).toHaveBeenCalledWith(1, { limit: 6 });
  });

  test('returns null sections when billing_cycle_day is not configured', async () => {
    const noBillingCard = { ...mockCardDetails, billing_cycle_day: null };
    paymentMethodService.getCreditCardWithComputedFields.mockResolvedValue(noBillingCard);
    creditCardPaymentRepository.findByPaymentMethodId.mockResolvedValue(mockPayments);

    await billingCycleController.getCreditCardDetail(req, res);

    expect(res.status).toHaveBeenCalledWith(200);
    const body = res.json.mock.calls[0][0];
    expect(body.cardDetails).toEqual(noBillingCard);
    expect(body.payments).toEqual(mockPayments);
    expect(body.statementBalanceInfo).toBeNull();
    expect(body.currentCycleStatus).toBeNull();
    expect(body.billingCycles).toEqual([]);
    expect(body.errors).toEqual([]);
    // Should NOT have called billing-cycle-related services
    expect(statementBalanceService.calculateStatementBalance).not.toHaveBeenCalled();
    expect(billingCycleHistoryService.getCurrentCycleStatus).not.toHaveBeenCalled();
    expect(billingCycleHistoryService.getUnifiedBillingCycles).not.toHaveBeenCalled();
  });

  test('defaults billingCycleLimit to 12 when not specified', async () => {
    paymentMethodService.getCreditCardWithComputedFields.mockResolvedValue(mockCardDetails);
    creditCardPaymentRepository.findByPaymentMethodId.mockResolvedValue([]);
    statementBalanceService.calculateStatementBalance.mockResolvedValue(null);
    billingCycleHistoryService.getCurrentCycleStatus.mockResolvedValue(null);
    billingCycleHistoryService.getUnifiedBillingCycles.mockResolvedValue({ billingCycles: [], autoGeneratedCount: 0, totalCount: 0 });

    await billingCycleController.getCreditCardDetail(req, res);

    expect(billingCycleHistoryService.getUnifiedBillingCycles).toHaveBeenCalledWith(1, { limit: 12 });
  });

  test('handles multiple sub-query failures gracefully', async () => {
    paymentMethodService.getCreditCardWithComputedFields.mockResolvedValue(mockCardDetails);
    creditCardPaymentRepository.findByPaymentMethodId.mockRejectedValue(new Error('payments error'));
    statementBalanceService.calculateStatementBalance.mockRejectedValue(new Error('balance error'));
    billingCycleHistoryService.getCurrentCycleStatus.mockRejectedValue(new Error('status error'));
    billingCycleHistoryService.getUnifiedBillingCycles.mockRejectedValue(new Error('cycles error'));

    await billingCycleController.getCreditCardDetail(req, res);

    expect(res.status).toHaveBeenCalledWith(200);
    const body = res.json.mock.calls[0][0];
    expect(body.cardDetails).toEqual(mockCardDetails);
    expect(body.payments).toEqual([]);
    expect(body.statementBalanceInfo).toBeNull();
    expect(body.currentCycleStatus).toBeNull();
    expect(body.billingCycles).toEqual([]);
    expect(body.errors).toHaveLength(4);
    const sections = body.errors.map(e => e.section);
    expect(sections).toContain('payments');
    expect(sections).toContain('statementBalance');
    expect(sections).toContain('currentCycleStatus');
    expect(sections).toContain('billingCycles');
  });
});
