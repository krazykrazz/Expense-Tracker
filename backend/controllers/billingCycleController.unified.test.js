const billingCycleController = require('./billingCycleController');
const billingCycleHistoryService = require('../services/billingCycleHistoryService');
const fc = require('fast-check');

// Mock the billing cycle history service
jest.mock('../services/billingCycleHistoryService');

/**
 * BillingCycleController Unified Endpoint Tests
 * 
 * Tests the unified billing cycles endpoint with valid and invalid inputs
 * Tests error responses and query parameter validation
 * Includes Property 8: Billing Cycles Sorted Descending
 * 
 * **Validates: Requirements 6.1, 8.1, 8.3, 8.4**
 */
describe('BillingCycleController - Unified Endpoint Tests', () => {
  let req, res;

  beforeEach(() => {
    jest.clearAllMocks();

    req = {
      query: {},
      params: {},
      body: {}
    };

    res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn().mockReturnThis()
    };
  });

  describe('GET /api/payment-methods/:id/billing-cycles/unified - getUnifiedBillingCycles', () => {
    test('should return unified billing cycles with default options', async () => {
      const mockResult = {
        billingCycles: [
          {
            id: 2,
            payment_method_id: 4,
            cycle_start_date: '2025-01-16',
            cycle_end_date: '2025-02-15',
            actual_statement_balance: 1234.56,
            calculated_statement_balance: 1189.23,
            effective_balance: 1234.56,
            balance_type: 'actual',
            transaction_count: 23,
            trend_indicator: { type: 'higher', icon: '↑', amount: 145.33, cssClass: 'trend-higher' }
          },
          {
            id: 1,
            payment_method_id: 4,
            cycle_start_date: '2024-12-16',
            cycle_end_date: '2025-01-15',
            actual_statement_balance: 0,
            calculated_statement_balance: 1089.23,
            effective_balance: 1089.23,
            balance_type: 'calculated',
            transaction_count: 18,
            trend_indicator: null
          }
        ],
        autoGeneratedCount: 1,
        totalCount: 2
      };

      req.params = { id: '4' };
      billingCycleHistoryService.getUnifiedBillingCycles.mockResolvedValue(mockResult);

      await billingCycleController.getUnifiedBillingCycles(req, res);

      expect(billingCycleHistoryService.getUnifiedBillingCycles).toHaveBeenCalledWith(4, {});
      expect(res.status).toHaveBeenCalledWith(200);
      expect(res.json).toHaveBeenCalledWith({
        success: true,
        billingCycles: mockResult.billingCycles,
        autoGeneratedCount: 1,
        totalCount: 2
      });
    });

    test('should return unified billing cycles with custom limit', async () => {
      const mockResult = {
        billingCycles: [],
        autoGeneratedCount: 0,
        totalCount: 0
      };

      req.params = { id: '4' };
      req.query = { limit: '6' };
      billingCycleHistoryService.getUnifiedBillingCycles.mockResolvedValue(mockResult);

      await billingCycleController.getUnifiedBillingCycles(req, res);

      expect(billingCycleHistoryService.getUnifiedBillingCycles).toHaveBeenCalledWith(4, { limit: 6 });
      expect(res.status).toHaveBeenCalledWith(200);
    });

    test('should return unified billing cycles with include_auto_generate=false', async () => {
      const mockResult = {
        billingCycles: [],
        autoGeneratedCount: 0,
        totalCount: 0
      };

      req.params = { id: '4' };
      req.query = { include_auto_generate: 'false' };
      billingCycleHistoryService.getUnifiedBillingCycles.mockResolvedValue(mockResult);

      await billingCycleController.getUnifiedBillingCycles(req, res);

      expect(billingCycleHistoryService.getUnifiedBillingCycles).toHaveBeenCalledWith(4, { includeAutoGenerate: false });
      expect(res.status).toHaveBeenCalledWith(200);
    });

    test('should return unified billing cycles with include_auto_generate=true', async () => {
      const mockResult = {
        billingCycles: [],
        autoGeneratedCount: 0,
        totalCount: 0
      };

      req.params = { id: '4' };
      req.query = { include_auto_generate: 'true' };
      billingCycleHistoryService.getUnifiedBillingCycles.mockResolvedValue(mockResult);

      await billingCycleController.getUnifiedBillingCycles(req, res);

      expect(billingCycleHistoryService.getUnifiedBillingCycles).toHaveBeenCalledWith(4, { includeAutoGenerate: true });
      expect(res.status).toHaveBeenCalledWith(200);
    });

    test('should accept include_auto_generate=1 as true', async () => {
      const mockResult = {
        billingCycles: [],
        autoGeneratedCount: 0,
        totalCount: 0
      };

      req.params = { id: '4' };
      req.query = { include_auto_generate: '1' };
      billingCycleHistoryService.getUnifiedBillingCycles.mockResolvedValue(mockResult);

      await billingCycleController.getUnifiedBillingCycles(req, res);

      expect(billingCycleHistoryService.getUnifiedBillingCycles).toHaveBeenCalledWith(4, { includeAutoGenerate: true });
    });

    test('should accept include_auto_generate=0 as false', async () => {
      const mockResult = {
        billingCycles: [],
        autoGeneratedCount: 0,
        totalCount: 0
      };

      req.params = { id: '4' };
      req.query = { include_auto_generate: '0' };
      billingCycleHistoryService.getUnifiedBillingCycles.mockResolvedValue(mockResult);

      await billingCycleController.getUnifiedBillingCycles(req, res);

      expect(billingCycleHistoryService.getUnifiedBillingCycles).toHaveBeenCalledWith(4, { includeAutoGenerate: false });
    });

    test('should return 400 for invalid payment method ID', async () => {
      req.params = { id: 'invalid' };

      await billingCycleController.getUnifiedBillingCycles(req, res);

      expect(res.status).toHaveBeenCalledWith(400);
      expect(res.json).toHaveBeenCalledWith({
        success: false,
        error: 'Invalid payment method ID'
      });
    });

    test('should return 400 for invalid limit (negative)', async () => {
      req.params = { id: '4' };
      req.query = { limit: '-1' };

      await billingCycleController.getUnifiedBillingCycles(req, res);

      expect(res.status).toHaveBeenCalledWith(400);
      expect(res.json).toHaveBeenCalledWith({
        success: false,
        error: 'Limit must be a positive integer'
      });
    });

    test('should return 400 for invalid limit (zero)', async () => {
      req.params = { id: '4' };
      req.query = { limit: '0' };

      await billingCycleController.getUnifiedBillingCycles(req, res);

      expect(res.status).toHaveBeenCalledWith(400);
      expect(res.json).toHaveBeenCalledWith({
        success: false,
        error: 'Limit must be a positive integer'
      });
    });

    test('should return 400 for invalid limit (non-numeric)', async () => {
      req.params = { id: '4' };
      req.query = { limit: 'abc' };

      await billingCycleController.getUnifiedBillingCycles(req, res);

      expect(res.status).toHaveBeenCalledWith(400);
      expect(res.json).toHaveBeenCalledWith({
        success: false,
        error: 'Limit must be a positive integer'
      });
    });

    test('should return 400 for invalid include_auto_generate value', async () => {
      req.params = { id: '4' };
      req.query = { include_auto_generate: 'yes' };

      await billingCycleController.getUnifiedBillingCycles(req, res);

      expect(res.status).toHaveBeenCalledWith(400);
      expect(res.json).toHaveBeenCalledWith({
        success: false,
        error: 'include_auto_generate must be a boolean (true/false)'
      });
    });

    test('should return 404 when payment method not found', async () => {
      req.params = { id: '999' };

      const error = new Error('Payment method not found');
      error.code = 'NOT_FOUND';
      billingCycleHistoryService.getUnifiedBillingCycles.mockRejectedValue(error);

      await billingCycleController.getUnifiedBillingCycles(req, res);

      expect(res.status).toHaveBeenCalledWith(404);
      expect(res.json).toHaveBeenCalledWith({
        success: false,
        error: 'Payment method not found'
      });
    });

    test('should return 400 when payment method is not a credit card', async () => {
      req.params = { id: '1' };

      const error = new Error('Billing cycle history only available for credit cards');
      error.code = 'VALIDATION_ERROR';
      billingCycleHistoryService.getUnifiedBillingCycles.mockRejectedValue(error);

      await billingCycleController.getUnifiedBillingCycles(req, res);

      expect(res.status).toHaveBeenCalledWith(400);
      expect(res.json).toHaveBeenCalledWith({
        success: false,
        error: 'Billing cycle history only available for credit cards'
      });
    });

    test('should return 400 when billing cycle day not configured', async () => {
      req.params = { id: '4' };

      const error = new Error('Billing cycle day not configured for this credit card');
      error.code = 'VALIDATION_ERROR';
      billingCycleHistoryService.getUnifiedBillingCycles.mockRejectedValue(error);

      await billingCycleController.getUnifiedBillingCycles(req, res);

      expect(res.status).toHaveBeenCalledWith(400);
      expect(res.json).toHaveBeenCalledWith({
        success: false,
        error: 'Billing cycle day not configured for this credit card'
      });
    });

    test('should return 500 for internal server error', async () => {
      req.params = { id: '4' };

      const error = new Error('Database connection failed');
      billingCycleHistoryService.getUnifiedBillingCycles.mockRejectedValue(error);

      await billingCycleController.getUnifiedBillingCycles(req, res);

      expect(res.status).toHaveBeenCalledWith(500);
      expect(res.json).toHaveBeenCalledWith({
        success: false,
        error: 'Internal server error while retrieving unified billing cycles'
      });
    });
  });

  /**
   * Property 8: Billing Cycles Sorted Descending
   * 
   * *For any* list of billing cycles returned by the unified endpoint, 
   * cycles SHALL be sorted by cycle_end_date in descending order (most recent first).
   * 
   * **Validates: Requirements 6.1**
   */
  describe('Property 8: Billing Cycles Sorted Descending', () => {
    // Helper to generate a valid date string
    const generateDateString = () => fc.tuple(
      fc.integer({ min: 2024, max: 2025 }),
      fc.integer({ min: 1, max: 12 }),
      fc.integer({ min: 1, max: 28 })
    ).map(([year, month, day]) => {
      const m = String(month).padStart(2, '0');
      const d = String(day).padStart(2, '0');
      return `${year}-${m}-${d}`;
    });

    test('Feature: unified-billing-cycles, Property 8: Billing cycles are sorted by cycle_end_date descending', async () => {
      // Generate random billing cycles and verify they come back sorted
      await fc.assert(
        fc.asyncProperty(
          // Generate 1-12 billing cycles with random dates
          fc.array(
            fc.record({
              id: fc.integer({ min: 1, max: 1000 }),
              payment_method_id: fc.constant(4),
              cycle_end_date: generateDateString(),
              actual_statement_balance: fc.integer({ min: 0, max: 10000 }),
              calculated_statement_balance: fc.integer({ min: 0, max: 10000 }),
              effective_balance: fc.integer({ min: 0, max: 10000 }),
              balance_type: fc.constantFrom('actual', 'calculated'),
              transaction_count: fc.integer({ min: 0, max: 100 }),
              trend_indicator: fc.oneof(
                fc.constant(null),
                fc.record({
                  type: fc.constantFrom('higher', 'lower', 'same'),
                  icon: fc.constantFrom('↑', '↓', '✓'),
                  amount: fc.integer({ min: 0, max: 1000 }),
                  cssClass: fc.constantFrom('trend-higher', 'trend-lower', 'trend-same')
                })
              )
            }),
            { minLength: 1, maxLength: 12 }
          ),
          async (cycles) => {
            // Reset mocks for each iteration
            jest.clearAllMocks();
            res.status.mockReturnThis();
            res.json.mockReturnThis();

            // Sort cycles by cycle_end_date descending (as the service should do)
            const sortedCycles = [...cycles].sort((a, b) => 
              new Date(b.cycle_end_date) - new Date(a.cycle_end_date)
            );

            const mockResult = {
              billingCycles: sortedCycles,
              autoGeneratedCount: 0,
              totalCount: sortedCycles.length
            };

            req.params = { id: '4' };
            billingCycleHistoryService.getUnifiedBillingCycles.mockResolvedValue(mockResult);

            await billingCycleController.getUnifiedBillingCycles(req, res);

            expect(res.status).toHaveBeenCalledWith(200);
            
            const responseData = res.json.mock.calls[0][0];
            const returnedCycles = responseData.billingCycles;

            // Verify cycles are sorted by cycle_end_date descending
            for (let i = 0; i < returnedCycles.length - 1; i++) {
              const currentDate = new Date(returnedCycles[i].cycle_end_date);
              const nextDate = new Date(returnedCycles[i + 1].cycle_end_date);
              expect(currentDate >= nextDate).toBe(true);
            }
          }
        ),
        { numRuns: 100 }
      );
    });
  });
});
