import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, waitFor, fireEvent, act, cleanup } from '@testing-library/react';

// Mock config
vi.mock('../config', () => ({
  API_ENDPOINTS: {
    PAYMENT_METHOD_BY_ID: (id) => `/api/payment-methods/${id}`,
    PAYMENT_METHOD_PAYMENTS: (id) => `/api/payment-methods/${id}/payments`,
    PAYMENT_METHOD_STATEMENTS: (id) => `/api/payment-methods/${id}/statements`,
    PAYMENT_METHOD_BILLING_CYCLES: (id) => `/api/payment-methods/${id}/billing-cycles`,
    PAYMENT_METHOD_STATEMENT_BALANCE: (id) => `/api/payment-methods/${id}/statement-balance`,
    PAYMENT_METHOD_STATEMENT: (id, statementId) => `/api/payment-methods/${id}/statements/${statementId}`,
    PAYMENT_METHOD_BILLING_CYCLE_CREATE: (id) => `/api/payment-methods/${id}/billing-cycles`,
    PAYMENT_METHOD_BILLING_CYCLE_HISTORY: (id) => `/api/payment-methods/${id}/billing-cycles/history`,
    PAYMENT_METHOD_BILLING_CYCLE_UPDATE: (id, cycleId) => `/api/payment-methods/${id}/billing-cycles/${cycleId}`,
    PAYMENT_METHOD_BILLING_CYCLE_DELETE: (id, cycleId) => `/api/payment-methods/${id}/billing-cycles/${cycleId}`,
    PAYMENT_METHOD_BILLING_CYCLE_CURRENT: (id) => `/api/payment-methods/${id}/billing-cycles/current`,
    PAYMENT_METHOD_BILLING_CYCLES_UNIFIED: (id) => `/api/payment-methods/${id}/billing-cycles/unified`,
    PAYMENT_METHOD_BILLING_CYCLE_PDF: (id, cycleId) => `/api/payment-methods/${id}/billing-cycles/${cycleId}/pdf`
  },
  default: 'http://localhost:2424'
}));

// Mock the API services
vi.mock('../services/paymentMethodApi', () => ({
  getPaymentMethod: vi.fn()
}));

vi.mock('../services/creditCardApi', () => ({
  getPayments: vi.fn(),
  getStatementBalance: vi.fn(),
  getCurrentCycleStatus: vi.fn(),
  getUnifiedBillingCycles: vi.fn(),
  deleteBillingCycle: vi.fn(),
  deletePayment: vi.fn(),
  getBillingCyclePdfUrl: vi.fn()
}));

import * as paymentMethodApi from '../services/paymentMethodApi';
import * as creditCardApi from '../services/creditCardApi';
import CreditCardDetailView from './CreditCardDetailView';

describe('CreditCardDetailView - Unified Billing Cycles', () => {
  // Base mock credit card with billing_cycle_day configured
  const mockCreditCardWithBillingCycle = {
    id: 1,
    type: 'credit_card',
    display_name: 'Test Card',
    full_name: 'Test Credit Card',
    current_balance: 500,
    statement_balance: 300,
    credit_limit: 5000,
    payment_due_day: 15,
    billing_cycle_day: 25,
    billing_cycle_start: 26,
    billing_cycle_end: 25,
    is_active: 1,
    current_cycle: {
      start_date: '2026-01-26',
      end_date: '2026-02-25',
      transaction_count: 15,
      total_amount: 450,
      payment_count: 1,
      payment_total: 200
    }
  };

  // Credit card without billing_cycle_day
  const mockCreditCardWithoutBillingCycle = {
    ...mockCreditCardWithBillingCycle,
    billing_cycle_day: null,
    statement_balance: null,
    current_cycle: null
  };

  // Mock statement balance info
  const mockStatementBalanceInfo = {
    statementBalance: 300,
    cycleStartDate: '2026-01-26',
    cycleEndDate: '2026-02-25',
    totalExpenses: 500,
    totalPayments: 200,
    isPaid: false
  };

  // Mock current cycle status
  const mockCycleStatus = {
    hasActualBalance: false,
    cycleStartDate: '2026-01-26',
    cycleEndDate: '2026-02-25',
    actualBalance: null,
    calculatedBalance: 300,
    daysUntilCycleEnd: 10,
    needsEntry: true
  };

  // Mock unified billing cycles response
  const mockUnifiedBillingCycles = {
    success: true,
    billingCycles: [
      {
        id: 1,
        payment_method_id: 1,
        cycle_start_date: '2026-01-26',
        cycle_end_date: '2026-02-25',
        actual_statement_balance: 350,
        calculated_statement_balance: 300,
        effective_balance: 350,
        balance_type: 'actual',
        transaction_count: 15,
        trend_indicator: {
          type: 'higher',
          icon: '↑',
          amount: 50,
          cssClass: 'trend-higher'
        },
        minimum_payment: 25,
        due_date: '2026-03-15',
        notes: null,
        statement_pdf_path: null
      },
      {
        id: 2,
        payment_method_id: 1,
        cycle_start_date: '2025-12-26',
        cycle_end_date: '2026-01-25',
        actual_statement_balance: 0,
        calculated_statement_balance: 300,
        effective_balance: 300,
        balance_type: 'calculated',
        transaction_count: 12,
        trend_indicator: {
          type: 'lower',
          icon: '↓',
          amount: 100,
          cssClass: 'trend-lower'
        },
        minimum_payment: null,
        due_date: null,
        notes: null,
        statement_pdf_path: null
      }
    ],
    autoGeneratedCount: 1,
    totalCount: 2
  };

  beforeEach(() => {
    vi.clearAllMocks();
    paymentMethodApi.getPaymentMethod.mockResolvedValue(mockCreditCardWithBillingCycle);
    creditCardApi.getPayments.mockResolvedValue([]);
    creditCardApi.getStatementBalance.mockResolvedValue(mockStatementBalanceInfo);
    creditCardApi.getCurrentCycleStatus.mockResolvedValue(mockCycleStatus);
    creditCardApi.getUnifiedBillingCycles.mockResolvedValue(mockUnifiedBillingCycles);
    creditCardApi.getBillingCyclePdfUrl.mockReturnValue('/api/payment-methods/1/billing-cycles/1/pdf');
  });

  afterEach(() => {
    cleanup();
    vi.restoreAllMocks();
  });

  /**
   * Test: Tab label is "Billing Cycles" not "Statements"
   * **Validates: Requirements 1.1**
   */
  describe('Tab Renaming', () => {
    it('should display "Billing Cycles" tab label instead of "Statements"', async () => {
      render(
        <CreditCardDetailView
          paymentMethodId={1}
          isOpen={true}
          onClose={() => {}}
          onUpdate={() => {}}
        />
      );

      await waitFor(() => {
        expect(screen.getByText('Test Card')).toBeInTheDocument();
      });

      // Should have "Billing Cycles" tab
      const billingCyclesTab = screen.getByRole('button', { name: /Billing Cycles/i });
      expect(billingCyclesTab).toBeInTheDocument();

      // Should NOT have "Statements" tab
      expect(screen.queryByRole('button', { name: /^Statements/i })).not.toBeInTheDocument();
    });

    it('should show count of billing cycles in tab label', async () => {
      render(
        <CreditCardDetailView
          paymentMethodId={1}
          isOpen={true}
          onClose={() => {}}
          onUpdate={() => {}}
        />
      );

      await waitFor(() => {
        expect(screen.getByText('Test Card')).toBeInTheDocument();
      });

      // Wait for unified billing cycles to load
      await waitFor(() => {
        const billingCyclesTab = screen.getByRole('button', { name: /Billing Cycles \(2\)/i });
        expect(billingCyclesTab).toBeInTheDocument();
      });
    });
  });

  /**
   * Test: Overview tab does not contain "Billing Cycle History" section
   * **Validates: Requirements 1.3**
   */
  describe('Overview Tab Content', () => {
    it('should NOT display "Billing Cycle History" collapsible section in Overview tab', async () => {
      render(
        <CreditCardDetailView
          paymentMethodId={1}
          isOpen={true}
          onClose={() => {}}
          onUpdate={() => {}}
        />
      );

      await waitFor(() => {
        expect(screen.getByText('Test Card')).toBeInTheDocument();
      });

      // Overview tab should be active by default
      const overviewTab = screen.getByRole('button', { name: /Overview/i });
      expect(overviewTab.classList.contains('active')).toBe(true);

      // Should NOT have "Billing Cycle History" section
      expect(screen.queryByText('Billing Cycle History')).not.toBeInTheDocument();
    });

    it('should still display "Current Billing Cycle" card in Overview tab', async () => {
      render(
        <CreditCardDetailView
          paymentMethodId={1}
          isOpen={true}
          onClose={() => {}}
          onUpdate={() => {}}
        />
      );

      await waitFor(() => {
        expect(screen.getByText('Test Card')).toBeInTheDocument();
      });

      // Should have "Current Billing Cycle" section
      expect(screen.getByText('Current Billing Cycle')).toBeInTheDocument();
    });

    it('should display transaction count and total spent in Current Billing Cycle card', async () => {
      render(
        <CreditCardDetailView
          paymentMethodId={1}
          isOpen={true}
          onClose={() => {}}
          onUpdate={() => {}}
        />
      );

      await waitFor(() => {
        expect(screen.getByText('Test Card')).toBeInTheDocument();
      });

      // Should show transaction count
      expect(screen.getByText('15')).toBeInTheDocument();
      expect(screen.getByText('Transactions')).toBeInTheDocument();

      // Should show total spent
      expect(screen.getByText('$450.00')).toBeInTheDocument();
      expect(screen.getByText('Total Spent')).toBeInTheDocument();
    });
  });

  /**
   * Test: Empty state when billing_cycle_day not configured
   * **Validates: Requirements 7.1, 7.3**
   */
  describe('Empty State for Billing Cycles', () => {
    it('should show empty state message when billing_cycle_day is not configured', async () => {
      paymentMethodApi.getPaymentMethod.mockResolvedValue(mockCreditCardWithoutBillingCycle);
      creditCardApi.getStatementBalance.mockResolvedValue(null);
      creditCardApi.getCurrentCycleStatus.mockResolvedValue(null);
      creditCardApi.getUnifiedBillingCycles.mockResolvedValue({ billingCycles: [] });

      render(
        <CreditCardDetailView
          paymentMethodId={1}
          isOpen={true}
          onClose={() => {}}
          onUpdate={() => {}}
        />
      );

      await waitFor(() => {
        expect(screen.getByText('Test Card')).toBeInTheDocument();
      });

      // Click on Billing Cycles tab
      const billingCyclesTab = screen.getByRole('button', { name: /Billing Cycles/i });
      await act(async () => {
        fireEvent.click(billingCyclesTab);
      });

      // Should show empty state message
      await waitFor(() => {
        expect(screen.getByText(/Configure a billing cycle day/i)).toBeInTheDocument();
      });
    });

    it('should show hint about editing card settings in empty state', async () => {
      paymentMethodApi.getPaymentMethod.mockResolvedValue(mockCreditCardWithoutBillingCycle);
      creditCardApi.getStatementBalance.mockResolvedValue(null);
      creditCardApi.getCurrentCycleStatus.mockResolvedValue(null);
      creditCardApi.getUnifiedBillingCycles.mockResolvedValue({ billingCycles: [] });

      render(
        <CreditCardDetailView
          paymentMethodId={1}
          isOpen={true}
          onClose={() => {}}
          onUpdate={() => {}}
        />
      );

      await waitFor(() => {
        expect(screen.getByText('Test Card')).toBeInTheDocument();
      });

      // Click on Billing Cycles tab
      const billingCyclesTab = screen.getByRole('button', { name: /Billing Cycles/i });
      await act(async () => {
        fireEvent.click(billingCyclesTab);
      });

      // Should show hint about editing settings
      await waitFor(() => {
        expect(screen.getByText(/Edit this card's settings/i)).toBeInTheDocument();
      });
    });
  });

  /**
   * Test: Unified Billing Cycles Tab Content
   * **Validates: Requirements 1.2, 6.1**
   */
  describe('Billing Cycles Tab Content', () => {
    it('should display unified billing cycles list when tab is clicked', async () => {
      render(
        <CreditCardDetailView
          paymentMethodId={1}
          isOpen={true}
          onClose={() => {}}
          onUpdate={() => {}}
        />
      );

      await waitFor(() => {
        expect(screen.getByText('Test Card')).toBeInTheDocument();
      });

      // Click on Billing Cycles tab
      const billingCyclesTab = screen.getByRole('button', { name: /Billing Cycles/i });
      await act(async () => {
        fireEvent.click(billingCyclesTab);
      });

      // Should show billing cycles header
      await waitFor(() => {
        expect(screen.getByText('Billing Cycles')).toBeInTheDocument();
      });
    });

    it('should call getUnifiedBillingCycles API when component loads', async () => {
      render(
        <CreditCardDetailView
          paymentMethodId={1}
          isOpen={true}
          onClose={() => {}}
          onUpdate={() => {}}
        />
      );

      await waitFor(() => {
        expect(screen.getByText('Test Card')).toBeInTheDocument();
      });

      // Should have called the unified billing cycles API
      expect(creditCardApi.getUnifiedBillingCycles).toHaveBeenCalledWith(1, { limit: 12, includeAutoGenerate: true });
    });
  });

  /**
   * Test: Enter Statement button visibility
   * **Validates: Requirements 10.1, 10.3**
   */
  describe('Enter Statement Button', () => {
    it('should show "Enter Statement" button when billing_cycle_day is configured', async () => {
      render(
        <CreditCardDetailView
          paymentMethodId={1}
          isOpen={true}
          onClose={() => {}}
          onUpdate={() => {}}
        />
      );

      await waitFor(() => {
        expect(screen.getByText('Test Card')).toBeInTheDocument();
      });

      // Click on Billing Cycles tab to see the cycles list
      const billingCyclesTab = screen.getByRole('button', { name: /Billing Cycles/i });
      await act(async () => {
        fireEvent.click(billingCyclesTab);
      });

      // Wait for billing cycles to load and show Enter Statement button for auto-generated cycle
      await waitFor(() => {
        expect(screen.getByRole('button', { name: /Enter Statement/i })).toBeInTheDocument();
      });
    });

    it('should NOT show "Enter Statement" button when billing_cycle_day is NOT configured', async () => {
      paymentMethodApi.getPaymentMethod.mockResolvedValue(mockCreditCardWithoutBillingCycle);
      creditCardApi.getStatementBalance.mockResolvedValue(null);
      creditCardApi.getCurrentCycleStatus.mockResolvedValue(null);
      creditCardApi.getUnifiedBillingCycles.mockResolvedValue({ success: true, billingCycles: [], autoGeneratedCount: 0, totalCount: 0 });

      render(
        <CreditCardDetailView
          paymentMethodId={1}
          isOpen={true}
          onClose={() => {}}
          onUpdate={() => {}}
        />
      );

      await waitFor(() => {
        expect(screen.getByText('Test Card')).toBeInTheDocument();
      });

      // Click on Billing Cycles tab
      const billingCyclesTab = screen.getByRole('button', { name: /Billing Cycles/i });
      await act(async () => {
        fireEvent.click(billingCyclesTab);
      });

      // Should NOT show Enter Statement button (no billing cycles)
      await waitFor(() => {
        expect(screen.queryByRole('button', { name: /Enter Statement/i })).not.toBeInTheDocument();
      });
    });

    it('should open billing cycle form when "Enter Statement" button is clicked', async () => {
      render(
        <CreditCardDetailView
          paymentMethodId={1}
          isOpen={true}
          onClose={() => {}}
          onUpdate={() => {}}
        />
      );

      await waitFor(() => {
        expect(screen.getByText('Test Card')).toBeInTheDocument();
      });

      // Click on Billing Cycles tab to see the cycles list
      const billingCyclesTab = screen.getByRole('button', { name: /Billing Cycles/i });
      await act(async () => {
        fireEvent.click(billingCyclesTab);
      });

      // Wait for Enter Statement button to appear
      await waitFor(() => {
        expect(screen.getByRole('button', { name: /Enter Statement/i })).toBeInTheDocument();
      });

      // Click Enter Statement button
      const enterStatementBtn = screen.getByRole('button', { name: /Enter Statement/i });
      await act(async () => {
        fireEvent.click(enterStatementBtn);
      });

      // Should show the billing cycle form
      // Note: Form shows "Edit Statement Balance" because the auto-generated cycle has an id
      await waitFor(() => {
        expect(screen.getByText('Edit Statement Balance')).toBeInTheDocument();
      });
    });
  });
});
