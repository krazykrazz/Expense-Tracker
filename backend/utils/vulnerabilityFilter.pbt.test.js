/**
 * Property-Based Tests: Vulnerability Severity Filtering
 * 
 * **Property 7: Vulnerability Severity Filtering**
 * **Validates: Requirements 1.2, 1.3**
 * 
 * For any npm audit result, the scanner should fail the build only when
 * high or critical vulnerabilities are found, and should allow the build
 * to pass when only low or moderate vulnerabilities exist.
 */

const fc = require('fast-check');
const {
  evaluateAuditResult,
  isFailSeverity,
  isWarnSeverity,
  SEVERITY_LEVELS,
} = require('../../backend/utils/vulnerabilityFilter');

// Detect CI environment
const isCI = process.env.CI === 'true' || process.env.GITHUB_ACTIONS === 'true';
const CI_SEED = 12345;

const pbtOptions = (overrides = {}) => {
  const envNumRuns = process.env.FAST_CHECK_NUM_RUNS
    ? parseInt(process.env.FAST_CHECK_NUM_RUNS, 10)
    : null;
  return {
    numRuns: envNumRuns || (isCI ? 25 : 50),
    seed: isCI ? CI_SEED : undefined,
    endOnFailure: true,
    ...overrides,
  };
};

// Arbitraries
const failSeverity = fc.constantFrom('high', 'critical');
const warnSeverity = fc.constantFrom('low', 'moderate');
const nonFailSeverity = fc.constantFrom('info', 'low', 'moderate');
const anySeverity = fc.constantFrom(...SEVERITY_LEVELS);

const vulnerabilityEntry = (severityArb) =>
  fc.record({
    severity: severityArb,
    name: fc.string({ minLength: 1, maxLength: 30 }).filter(s => s.trim().length > 0),
  });

const auditResult = (severityArb, minVulns = 1, maxVulns = 10) =>
  fc.array(vulnerabilityEntry(severityArb), { minLength: minVulns, maxLength: maxVulns }).map(
    (entries) => ({
      vulnerabilities: Object.fromEntries(
        entries.map((e, i) => [`vuln-${i}`, { severity: e.severity }])
      ),
    })
  );

describe('Property 7: Vulnerability Severity Filtering', () => {
  /**
   * Validates: Requirement 1.2
   * WHEN npm audit finds vulnerabilities of severity "high" or "critical",
   * THE CI_Pipeline SHALL fail the check.
   */
  test('build fails when any high or critical vulnerabilities exist', () => {
    fc.assert(
      fc.property(
        auditResult(failSeverity),
        (result) => {
          const evaluation = evaluateAuditResult(result);
          expect(evaluation.shouldFail).toBe(true);
          expect(evaluation.highCount + evaluation.criticalCount).toBeGreaterThan(0);
        }
      ),
      pbtOptions()
    );
  });

  /**
   * Validates: Requirement 1.3
   * WHEN npm audit finds only "low" or "moderate" vulnerabilities,
   * THE CI_Pipeline SHALL log warnings but not fail the build.
   */
  test('build passes when only low or moderate vulnerabilities exist', () => {
    fc.assert(
      fc.property(
        auditResult(nonFailSeverity),
        (result) => {
          const evaluation = evaluateAuditResult(result);
          expect(evaluation.shouldFail).toBe(false);
        }
      ),
      pbtOptions()
    );
  });

  /**
   * Validates: Requirements 1.2, 1.3
   * Mixed vulnerabilities: if ANY high/critical exist among low/moderate,
   * the build should still fail.
   */
  test('build fails when high/critical mixed with low/moderate', () => {
    fc.assert(
      fc.property(
        auditResult(nonFailSeverity, 1, 5),
        auditResult(failSeverity, 1, 3),
        (safeResult, dangerousResult) => {
          // Merge both into one audit result
          const merged = {
            vulnerabilities: {
              ...safeResult.vulnerabilities,
              ...Object.fromEntries(
                Object.entries(dangerousResult.vulnerabilities).map(([k, v]) => [`danger-${k}`, v])
              ),
            },
          };
          const evaluation = evaluateAuditResult(merged);
          expect(evaluation.shouldFail).toBe(true);
        }
      ),
      pbtOptions()
    );
  });

  /**
   * Validates: Requirements 1.2, 1.3
   * Empty audit results should not fail the build.
   */
  test('build passes with no vulnerabilities', () => {
    const evaluation = evaluateAuditResult({ vulnerabilities: {} });
    expect(evaluation.shouldFail).toBe(false);
    expect(evaluation.highCount).toBe(0);
    expect(evaluation.criticalCount).toBe(0);
  });

  /**
   * Validates: Requirements 1.2, 1.3
   * isFailSeverity correctly classifies all severity levels.
   */
  test('severity classification is consistent across all levels', () => {
    fc.assert(
      fc.property(
        anySeverity,
        (severity) => {
          const fails = isFailSeverity(severity);
          const warns = isWarnSeverity(severity);
          // A severity cannot both fail and warn
          expect(fails && warns).toBe(false);
          // high and critical must fail
          if (severity === 'high' || severity === 'critical') {
            expect(fails).toBe(true);
          }
          // low and moderate must warn
          if (severity === 'low' || severity === 'moderate') {
            expect(warns).toBe(true);
          }
        }
      ),
      pbtOptions()
    );
  });
});
