name: CI

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - '.kiro/steering/**'
      - 'CHANGELOG.md'
  pull_request:
    branches:
      - main
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - '.kiro/steering/**'
      - 'CHANGELOG.md'
  workflow_dispatch:
    inputs:
      health_check_timeout:
        description: 'Health check HTTP timeout in seconds'
        required: false
        default: '30'
        type: string
      health_check_retries:
        description: 'Number of health check retry attempts'
        required: false
        default: '10'
        type: string

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  backend-unit-tests:
    name: Backend Unit Tests
    runs-on: ubuntu-latest
    if: github.actor != 'dependabot[bot]'
    defaults:
      run:
        working-directory: backend

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Validate test naming conventions
        run: node ../scripts/validate-test-naming.js

      - name: Record test start time
        id: test_start
        run: echo "start=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Run unit tests
        run: npx cross-env NODE_ENV=test CI=true jest --bail --testPathIgnorePatterns=pbt --testPathIgnorePatterns="backup.*(integration|pbt)"
        env:
          CI: true

      - name: Run backup integration tests (serial)
        run: npx cross-env NODE_ENV=test CI=true jest --bail --runInBand --testPathPatterns="backup.*integration\\.test"
        env:
          CI: true

      - name: Check runtime budget
        if: always()
        run: |
          ELAPSED=$(( $(date +%s) - ${{ steps.test_start.outputs.start }} ))
          node ../scripts/check-test-budget.js backend-unit-tests $ELAPSED
        env:
          COMMIT_MESSAGE: ${{ github.event.head_commit.message }}

  backend-pbt-shards:
    name: Backend PBT Shard ${{ matrix.shard }}
    runs-on: ubuntu-latest
    if: github.actor != 'dependabot[bot]'
    strategy:
      fail-fast: true
      matrix:
        shard: ['1/3', '2/3', '3/3']
    defaults:
      run:
        working-directory: backend

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Record PBT start time
        id: pbt_start
        run: echo "start=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Run PBT tests (shard ${{ matrix.shard }})
        run: npx cross-env NODE_ENV=test CI=true FAST_CHECK_NUM_RUNS=15 jest --bail --testPathPatterns=pbt --testPathIgnorePatterns="backup" --shard=${{ matrix.shard }}

      - name: Run backup tests (serial, shard 1 only)
        if: matrix.shard == '1/3'
        run: npm run test:backup:ci

      - name: Check runtime budget
        if: always()
        run: |
          ELAPSED=$(( $(date +%s) - ${{ steps.pbt_start.outputs.start }} ))
          node ../scripts/check-test-budget.js backend-pbt-shard $ELAPSED
        env:
          COMMIT_MESSAGE: ${{ github.event.head_commit.message }}

  backend-pbt-tests:
    name: Backend PBT Tests
    runs-on: ubuntu-latest
    if: always() && github.actor != 'dependabot[bot]'
    needs: backend-pbt-shards
    steps:
      - name: Check shard results
        run: |
          if [ "${{ needs.backend-pbt-shards.result }}" != "success" ]; then
            echo "PBT shards failed or were cancelled"
            exit 1
          fi
          echo "All PBT shards passed"

      - name: Checkout code
        if: needs.backend-pbt-shards.result == 'success'
        uses: actions/checkout@v6

      - name: Setup Node.js
        if: needs.backend-pbt-shards.result == 'success'
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      - name: Validate PBT guardrails
        if: needs.backend-pbt-shards.result == 'success'
        run: node scripts/validate-pbt-guardrails.js

  frontend-tests:
    name: Frontend Tests
    runs-on: ubuntu-latest
    if: github.actor != 'dependabot[bot]'
    defaults:
      run:
        working-directory: frontend

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Validate test naming conventions
        run: node ../scripts/validate-test-naming.js

      - name: Validate no raw fetch() calls
        run: node ../scripts/validate-no-raw-fetch.js

      - name: Record test start time
        id: test_start
        run: echo "start=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Run tests
        run: npx vitest --run --exclude '**/App.performance.test.jsx'

      - name: Check runtime budget
        if: always()
        run: |
          ELAPSED=$(( $(date +%s) - ${{ steps.test_start.outputs.start }} ))
          node ../scripts/check-test-budget.js frontend-tests $ELAPSED
        env:
          COMMIT_MESSAGE: ${{ github.event.head_commit.message }}

  security-audit:
    name: Security Audit
    runs-on: ubuntu-latest
    if: github.actor != 'dependabot[bot]'

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      - name: Install backend dependencies
        run: npm ci
        working-directory: backend

      - name: Install frontend dependencies
        run: npm ci
        working-directory: frontend

      - name: Run backend security audit
        id: backend_audit
        run: |
          echo "## Security Audit Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Backend Dependencies" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if npm audit --audit-level=high 2>&1 | tee audit-output.txt; then
            echo "✅ No high or critical vulnerabilities found" >> $GITHUB_STEP_SUMMARY
            echo "backend_status=pass" >> $GITHUB_OUTPUT
          else
            echo "❌ High or critical vulnerabilities detected:" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat audit-output.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "backend_status=fail" >> $GITHUB_OUTPUT
          fi
        working-directory: backend
        continue-on-error: true

      - name: Run frontend security audit
        id: frontend_audit
        run: |
          echo "### Frontend Dependencies" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if npm audit --audit-level=high 2>&1 | tee audit-output.txt; then
            echo "✅ No high or critical vulnerabilities found" >> $GITHUB_STEP_SUMMARY
            echo "frontend_status=pass" >> $GITHUB_OUTPUT
          else
            echo "❌ High or critical vulnerabilities detected:" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat audit-output.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "frontend_status=fail" >> $GITHUB_OUTPUT
          fi
        working-directory: frontend
        continue-on-error: true

      - name: Fail on high or critical vulnerabilities
        if: steps.backend_audit.outputs.backend_status == 'fail' || steps.frontend_audit.outputs.frontend_status == 'fail'
        run: |
          echo "::error::Security audit found high or critical vulnerabilities"
          exit 1

  test-health-report:
    name: Test Health Report
    runs-on: ubuntu-latest
    if: always() && github.actor != 'dependabot[bot]'
    needs: [backend-unit-tests, backend-pbt-tests, frontend-tests]
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      - name: Report test health
        run: node scripts/report-test-health.js >> $GITHUB_STEP_SUMMARY
        env:
          GITHUB_ACTIONS: true

  build-and-push-ghcr:
    name: Build and Push to GHCR
    runs-on: ubuntu-latest
    needs: [backend-unit-tests, backend-pbt-tests, frontend-tests]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push' && github.actor != 'dependabot[bot]'
    permissions:
      contents: write
      packages: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        run: |
          echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "version=$(jq -r .version backend/package.json)" >> $GITHUB_OUTPUT
          echo "build_date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT
      
      - name: Build and load Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          load: true
          push: false
          tags: |
            ghcr.io/${{ github.repository_owner }}/expense-tracker:${{ steps.meta.outputs.sha_short }}
          build-args: |
            IMAGE_TAG=${{ steps.meta.outputs.sha_short }}
            BUILD_DATE=${{ steps.meta.outputs.build_date }}
            GIT_COMMIT=${{ steps.meta.outputs.sha_short }}
          labels: |
            org.opencontainers.image.created=${{ steps.meta.outputs.build_date }}
            org.opencontainers.image.version=${{ steps.meta.outputs.version }}
            org.opencontainers.image.revision=${{ steps.meta.outputs.sha_short }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.title=expense-tracker
            org.opencontainers.image.description=Personal expense tracking application
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Run Trivy vulnerability scan
        uses: aquasecurity/trivy-action@0.29.0
        with:
          image-ref: 'ghcr.io/${{ github.repository_owner }}/expense-tracker:${{ steps.meta.outputs.sha_short }}'
          format: 'table'
          output: 'trivy-results.txt'
          exit-code: '1'
          severity: 'CRITICAL,HIGH'
          vuln-type: 'os,library'

      - name: Generate full Trivy vulnerability report
        if: always()
        uses: aquasecurity/trivy-action@0.29.0
        with:
          image-ref: 'ghcr.io/${{ github.repository_owner }}/expense-tracker:${{ steps.meta.outputs.sha_short }}'
          format: 'table'
          output: 'trivy-results.txt'
          exit-code: '0'
          severity: 'CRITICAL,HIGH,MEDIUM,LOW'
          vuln-type: 'os,library'

      - name: Upload Trivy scan results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-scan-${{ steps.meta.outputs.sha_short }}
          path: trivy-results.txt
          retention-days: 30

      - name: Write Trivy summary
        if: always()
        run: |
          echo "## Docker Image Vulnerability Scan" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** \`ghcr.io/${{ github.repository_owner }}/expense-tracker:${{ steps.meta.outputs.sha_short }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -f trivy-results.txt ]; then
            CRITICAL=$(grep -c "CRITICAL" trivy-results.txt || true)
            HIGH=$(grep -c "HIGH" trivy-results.txt || true)
            MEDIUM=$(grep -c "MEDIUM" trivy-results.txt || true)
            LOW=$(grep -c "LOW" trivy-results.txt || true)
            echo "| Severity | Count |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| CRITICAL | $CRITICAL |" >> $GITHUB_STEP_SUMMARY
            echo "| HIGH | $HIGH |" >> $GITHUB_STEP_SUMMARY
            echo "| MEDIUM | $MEDIUM |" >> $GITHUB_STEP_SUMMARY
            echo "| LOW | $LOW |" >> $GITHUB_STEP_SUMMARY
          else
            echo "⚠️ No scan results file found" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Push Docker image to GHCR
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/expense-tracker:${{ steps.meta.outputs.sha_short }}
            ghcr.io/${{ github.repository_owner }}/expense-tracker:v${{ steps.meta.outputs.version }}
          build-args: |
            IMAGE_TAG=${{ steps.meta.outputs.sha_short }}
            BUILD_DATE=${{ steps.meta.outputs.build_date }}
            GIT_COMMIT=${{ steps.meta.outputs.sha_short }}
          labels: |
            org.opencontainers.image.created=${{ steps.meta.outputs.build_date }}
            org.opencontainers.image.version=${{ steps.meta.outputs.version }}
            org.opencontainers.image.revision=${{ steps.meta.outputs.sha_short }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.title=expense-tracker
            org.opencontainers.image.description=Personal expense tracking application
          annotations: |
            org.opencontainers.image.created=${{ steps.meta.outputs.build_date }}
            org.opencontainers.image.version=${{ steps.meta.outputs.version }}
            org.opencontainers.image.revision=${{ steps.meta.outputs.sha_short }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Prepare docker-compose for release
        run: |
          # Create a version-specific docker-compose file
          sed "s/{owner}/${{ github.repository_owner }}/g; s/:latest/:v${{ steps.meta.outputs.version }}/g" \
            docker-compose.ghcr.yml > docker-compose-v${{ steps.meta.outputs.version }}.yml
      
      - name: Check if release exists
        id: check_release
        run: |
          if gh release view "v${{ steps.meta.outputs.version }}" &>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Create or update release
        run: |
          VERSION="v${{ steps.meta.outputs.version }}"
          ASSET="docker-compose-v${{ steps.meta.outputs.version }}.yml"

          if [ "${{ steps.check_release.outputs.exists }}" = "true" ]; then
            echo "Release $VERSION already exists, uploading asset..."
            gh release upload "$VERSION" "$ASSET" --clobber
          else
            echo "Creating new release $VERSION..."
            echo "## Pre-Built Container Image Available" > release_notes.md
            echo "" >> release_notes.md
            echo "This release is available as a pre-built Docker image at GitHub Container Registry." >> release_notes.md
            echo "" >> release_notes.md
            echo "### Quick Start" >> release_notes.md
            echo "" >> release_notes.md
            echo "Download the docker-compose file:" >> release_notes.md
            echo "https://github.com/${{ github.repository }}/releases/download/$VERSION/$ASSET" >> release_notes.md
            echo "" >> release_notes.md
            echo "Then run: docker-compose -f $ASSET up -d" >> release_notes.md
            echo "" >> release_notes.md
            echo "### Container Images" >> release_notes.md
            echo "" >> release_notes.md
            echo "- ghcr.io/${{ github.repository_owner }}/expense-tracker:$VERSION (this release)" >> release_notes.md
            echo "- ghcr.io/${{ github.repository_owner }}/expense-tracker:${{ steps.meta.outputs.sha_short }} (commit SHA)" >> release_notes.md
            echo "- ghcr.io/${{ github.repository_owner }}/expense-tracker:latest (latest main)" >> release_notes.md
            echo "" >> release_notes.md
            echo "See CHANGELOG.md for detailed changes." >> release_notes.md

            # Handle race condition: deploy script may create the release between
            # the check and this step. If gh release create fails because the release
            # was created externally, fall back to uploading the asset.
            if ! gh release create "$VERSION" "$ASSET" \
              --title "Release $VERSION" \
              --notes-file release_notes.md 2>create_err.txt; then
              echo "gh release create failed, checking if release was created externally..."
              if gh release view "$VERSION" &>/dev/null; then
                echo "Release $VERSION now exists (created externally), uploading asset..."
                gh release upload "$VERSION" "$ASSET" --clobber
              else
                echo "::error::Failed to create release and release does not exist"
                cat create_err.txt
                exit 1
              fi
            fi
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  deployment-health-check:
    name: Deployment Health Check
    runs-on: ubuntu-latest
    needs: [build-and-push-ghcr]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push' && github.actor != 'dependabot[bot]'
    permissions:
      packages: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract image metadata
        id: meta
        run: |
          echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "image=ghcr.io/${{ github.repository_owner }}/expense-tracker:$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Store previous deployment SHA
        id: previous
        run: |
          REGISTRY="ghcr.io/${{ github.repository_owner }}"
          IMAGE_NAME="expense-tracker"
          CURRENT_SHA="${{ steps.meta.outputs.sha_short }}"

          # Pull :latest and extract the OCI revision label (previous commit SHA)
          PREVIOUS_SHA="none"
          if docker pull "$REGISTRY/$IMAGE_NAME:latest" 2>/dev/null; then
            PREV=$(docker inspect --format='{{index .Config.Labels "org.opencontainers.image.revision"}}' \
              "$REGISTRY/$IMAGE_NAME:latest" 2>/dev/null || echo "")
            if [ -n "$PREV" ] && [ "$PREV" != "$CURRENT_SHA" ]; then
              PREVIOUS_SHA="$PREV"
              echo "Found previous deployment SHA: $PREVIOUS_SHA"
            else
              echo "Latest image has same SHA as current build ($CURRENT_SHA), no rollback target"
            fi
          else
            echo "No previous deployment found at :latest tag"
          fi

          echo "previous_sha=$PREVIOUS_SHA" >> $GITHUB_OUTPUT
          echo "registry=$REGISTRY" >> $GITHUB_OUTPUT
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "Current SHA: $CURRENT_SHA"
          echo "Previous deployment SHA: $PREVIOUS_SHA"

      - name: Pull deployed Docker image
        run: docker pull "${{ steps.meta.outputs.image }}"

      - name: Start container
        id: start_container
        run: |
          CONFIG_DIR=$(mktemp -d)
          # Make writable by container's node user (UID 1000) without requiring root
          chmod -R 777 "$CONFIG_DIR"
          echo "config_dir=$CONFIG_DIR" >> $GITHUB_OUTPUT
          docker run -d \
            --name expense-tracker-health-check \
            -p 2424:2424 \
            -v "$CONFIG_DIR:/config" \
            -e NODE_ENV=production \
            -e LOG_LEVEL=info \
            "${{ steps.meta.outputs.image }}"

      - name: Wait for container initialization
        run: sleep 10

      - name: Make health check script executable
        run: chmod +x scripts/health-check.sh

      - name: Run backend health check
        id: backend_health
        run: |
          RETRIES=${{ inputs.health_check_retries || '10' }}
          TIMEOUT=${{ inputs.health_check_timeout || '30' }}
          ./scripts/health-check.sh http://localhost:2424/api/health "$RETRIES" 3 "$TIMEOUT"
        continue-on-error: true

      - name: Run frontend health check
        id: frontend_health
        run: |
          RETRIES=${{ inputs.health_check_retries || '10' }}
          TIMEOUT=${{ inputs.health_check_timeout || '30' }}
          ./scripts/health-check.sh http://localhost:2424/ "$RETRIES" 3 "$TIMEOUT"
        continue-on-error: true

      - name: Report health check results
        if: always()
        run: |
          echo "## Deployment Health Check Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** \`${{ steps.meta.outputs.image }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.backend_health.outcome }}" = "success" ]; then
            echo "✅ Backend health check: **PASSED**" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ Backend health check: **FAILED**" >> $GITHUB_STEP_SUMMARY
          fi
          if [ "${{ steps.frontend_health.outcome }}" = "success" ]; then
            echo "✅ Frontend health check: **PASSED**" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ Frontend health check: **FAILED**" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Collect container logs on failure
        if: steps.backend_health.outcome == 'failure' || steps.frontend_health.outcome == 'failure'
        run: |
          echo "::group::Container logs"
          docker logs expense-tracker-health-check 2>&1 || true
          echo "::endgroup::"
          echo ""
          echo "::group::Container status"
          docker inspect expense-tracker-health-check --format='{{.State.Status}}' || true
          echo "::endgroup::"

      - name: Stop container
        if: always()
        run: |
          docker stop expense-tracker-health-check || true
          docker rm expense-tracker-health-check || true
          # Clean up temporary /config volume directory
          if [ -n "${{ steps.start_container.outputs.config_dir }}" ]; then
            rm -rf "${{ steps.start_container.outputs.config_dir }}" || true
          fi

      - name: Initiate rollback on health check failure
        id: rollback
        if: steps.backend_health.outcome == 'failure' || steps.frontend_health.outcome == 'failure'
        run: |
          ROLLBACK_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          echo "::warning::[$ROLLBACK_TIMESTAMP] Health checks failed, initiating rollback"
          echo "  Failed SHA: ${{ steps.meta.outputs.sha_short }}"
          echo "  Previous SHA: ${{ steps.previous.outputs.previous_sha }}"
          echo "  Backend: ${{ steps.backend_health.outcome }}"
          echo "  Frontend: ${{ steps.frontend_health.outcome }}"

          if [ "${{ steps.previous.outputs.previous_sha }}" = "none" ]; then
            echo "::error::[$ROLLBACK_TIMESTAMP] No previous deployment available for rollback"
            echo "rollback_result=no_previous" >> $GITHUB_OUTPUT
            exit 1
          fi

          chmod +x scripts/rollback.sh
          ROLLBACK_OUTPUT=$(./scripts/rollback.sh \
            "${{ steps.previous.outputs.previous_sha }}" \
            "${{ steps.previous.outputs.registry }}" \
            "${{ steps.previous.outputs.image_name }}" \
            "expense-tracker-health-check")
          echo "$ROLLBACK_OUTPUT"

          # Capture config_dir from rollback script output for cleanup
          ROLLBACK_CONFIG_DIR=$(echo "$ROLLBACK_OUTPUT" | grep '^config_dir=' | tail -1 | cut -d= -f2-)
          if [ -n "$ROLLBACK_CONFIG_DIR" ]; then
            echo "rollback_config_dir=$ROLLBACK_CONFIG_DIR" >> $GITHUB_OUTPUT
          fi

          echo "rollback_result=deployed" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Run health checks on rolled-back deployment
        id: rollback_health
        if: steps.rollback.outcome == 'success' && steps.rollback.outputs.rollback_result == 'deployed'
        run: |
          ROLLBACK_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          echo "[$ROLLBACK_TIMESTAMP] Running health checks on rolled-back deployment..."

          chmod +x scripts/health-check.sh
          BACKEND_OK=true
          FRONTEND_OK=true

          ./scripts/health-check.sh http://localhost:2424/api/health 5 3 30 || BACKEND_OK=false
          ./scripts/health-check.sh http://localhost:2424/ 5 3 30 || FRONTEND_OK=false

          COMPLETION_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          if [ "$BACKEND_OK" = "true" ] && [ "$FRONTEND_OK" = "true" ]; then
            echo "[$COMPLETION_TIMESTAMP] ✓ Rollback health checks passed"
            echo "rollback_health=passed" >> $GITHUB_OUTPUT
          else
            echo "[$COMPLETION_TIMESTAMP] ✗ Rollback health checks failed"
            echo "  Backend: $BACKEND_OK, Frontend: $FRONTEND_OK"
            echo "rollback_health=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
        continue-on-error: true

      - name: Report rollback results
        if: steps.rollback.outcome == 'success' || steps.rollback.outcome == 'failure'
        run: |
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Rollback Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** Health check failure for SHA \`${{ steps.meta.outputs.sha_short }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Previous SHA:** \`${{ steps.previous.outputs.previous_sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $TIMESTAMP" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.rollback.outputs.rollback_result }}" = "no_previous" ]; then
            echo "❌ Rollback: **SKIPPED** (no previous deployment available)" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.rollback_health.outputs.rollback_health }}" = "passed" ]; then
            echo "✅ Rollback: **SUCCESSFUL**" >> $GITHUB_STEP_SUMMARY
            echo "✅ Rollback health checks: **PASSED**" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ Rollback: **FAILED**" >> $GITHUB_STEP_SUMMARY
            echo "⚠️ **Manual intervention required**" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Clean up rollback config directory
        if: always()
        run: |
          if [ -n "${{ steps.rollback.outputs.rollback_config_dir }}" ]; then
            rm -rf "${{ steps.rollback.outputs.rollback_config_dir }}" || true
          fi

      - name: Generate deployment metadata
        id: deployment_metadata
        if: always()
        run: |
          DEPLOY_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          VERSION=$(jq -r .version backend/package.json)

          # Determine deployment status
          if [ "${{ steps.backend_health.outcome }}" = "success" ] && [ "${{ steps.frontend_health.outcome }}" = "success" ]; then
            DEPLOY_STATUS="success"
          elif [ "${{ steps.rollback_health.outputs.rollback_health }}" = "passed" ]; then
            DEPLOY_STATUS="rolled_back"
          else
            DEPLOY_STATUS="failed"
          fi

          # Determine health check results
          BACKEND_HEALTH="failed"
          FRONTEND_HEALTH="failed"
          [ "${{ steps.backend_health.outcome }}" = "success" ] && BACKEND_HEALTH="passed"
          [ "${{ steps.frontend_health.outcome }}" = "success" ] && FRONTEND_HEALTH="passed"

          # Build metadata JSON
          METADATA=$(cat <<EOF
          {
            "sha": "${{ steps.meta.outputs.sha_short }}",
            "timestamp": "$DEPLOY_TIMESTAMP",
            "environment": "production",
            "version": "$VERSION",
            "status": "$DEPLOY_STATUS",
            "healthChecks": {
              "backend": "$BACKEND_HEALTH",
              "frontend": "$FRONTEND_HEALTH"
            }
          }
          EOF
          )

          # Add rollback info if applicable
          if [ "$DEPLOY_STATUS" = "rolled_back" ]; then
            METADATA=$(echo "$METADATA" | jq --arg prevSha "${{ steps.previous.outputs.previous_sha }}" \
              --arg reason "Health check failure" \
              --arg ts "$DEPLOY_TIMESTAMP" \
              '. + { rollbackInfo: { previousSha: $prevSha, reason: $reason, timestamp: $ts } }')
          fi

          echo "$METADATA" > deployment-record.json
          echo "Deployment metadata generated:"
          cat deployment-record.json

          echo "deploy_status=$DEPLOY_STATUS" >> $GITHUB_OUTPUT

      - name: Upload deployment record
        if: always()
        uses: actions/upload-artifact@v7
        with:
          name: deployment-${{ steps.meta.outputs.sha_short }}
          path: deployment-record.json
          retention-days: 30

      - name: Report deployment state in summary
        if: always()
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment State" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** \`${{ steps.deployment_metadata.outputs.deploy_status }}\`" >> $GITHUB_STEP_SUMMARY
          if [ -f deployment-record.json ]; then
            echo '```json' >> $GITHUB_STEP_SUMMARY
            cat deployment-record.json >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

      - name: Fail on health check failure
        if: steps.backend_health.outcome == 'failure' || steps.frontend_health.outcome == 'failure'
        run: |
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          echo "::error::[$TIMESTAMP] Deployment health checks failed for SHA ${{ steps.meta.outputs.sha_short }}"

          if [ "${{ steps.rollback_health.outputs.rollback_health }}" = "passed" ]; then
            echo "Rollback to ${{ steps.previous.outputs.previous_sha }} was successful"
          elif [ "${{ steps.rollback.outputs.rollback_result }}" = "no_previous" ]; then
            echo "::error::No previous deployment available for rollback - manual intervention required"
          else
            echo "::error::[$TIMESTAMP] Rollback also failed - manual intervention required"
            echo "::error::HALT: All automated recovery actions exhausted"
          fi
          exit 1
